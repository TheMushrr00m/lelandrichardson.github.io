{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "a575ff0a-7d38-5156-b71a-1567c735799f",
      "excerpt": "Concept: Underlying Mental Model\nAt its core, R4A is used to efficiently build and maintain tree-like data structures, and provide a…",
      "html": "<p>Concept: Underlying Mental Model\nAt its core, R4A is used to efficiently build and maintain tree-like data structures, and provide a programming model to dynamically update and maintain changing state of parts of that tree over time. </p>\n<p>One of the most compelling use cases for this type of a system is to build user interfaces (UIs). UIs are typically tree-like data structures that change over time. In the Android ecosystem, there are several different types of trees that you could consider. The most common one is Android Views. Other examples include Crane ComponentNodes, Vector Graphics, Display Lists or Spannables.</p>\n<p>For the sake of generality and simplicity, lets define a basic tree-like data structure that we can target in this example:</p>\n<p>abstract class Node {\nval children = mutableListOf<Node>()\n}</p>\n<p>class Box : Node()</p>\n<p>class Text(var text: String) : Node()</p>\n<p>Since our example use case is building UIs, let’s imagine that there is a way to take a tree of Nodes, and render their current state to the screen:</p>\n<p>fun renderNodeToScreen(node: Node) { /* … */ }</p>\n<p>Different UIs serve different purposes, and that is what makes up the application-specific logic of a UI. For instance, a “To Do List” application will need to render lists of “To Do” items. One way to do this is to create a function that just transforms our list of items into a tree of Boxes:</p>\n<p>fun TodoApp(items: List<TodoItem>) : Node  {\nreturn Box().apply {\nfor (item in items) {\nchildren.add(Box().apply {\nchildren.add(\nText(”[${if (item.completed) “x” else ” “}] ${item.title}”)\n)\n})\n}\n}\n}</p>\n<p>This can be used elsewhere in your app to render the UI to the screen in response to your application-specific data model:</p>\n<p>renderNodeToScreen(TodoApp(items))</p>\n<p>There are a few problems with this approach:</p>\n<p>It is difficult to break the logic of transforming data into this tree into smaller pieces.\nUIs can often have very large trees, but only small parts of them change dynamically\nEvery time we want to update something, we end up recreating (reallocating) the entire tree</p>\n<p>To address some of these issues, lets create an abstraction for “emitting” nodes into a context object, instead of explicitly adding nodes to the children array of the parent.</p>\n<p>interface Composer {\n// add node as a child to the current Node, execute <code class=\"language-text\">block</code> with <code class=\"language-text\">node</code> as the\n// current Node\nfun emit(node: Node, block: () -> Unit = {})\n}</p>\n<p>Now we can imagine having a function called <code class=\"language-text\">compose</code> with the following shape:</p>\n<p>// The Node emitted when <code class=\"language-text\">block</code> runs will get returned\nfun compose(block: Composer.() -> Unit): Node { /* … */ }</p>\n<p>Using this new abstraction, we can rewrite our UI above:</p>\n<p>fun Composer.TodoApp(items: List<TodoItem>) {\nemit(Box()) {\nfor (item in items) {\nemit(Text(”[${if (item.completed) “x” else ” “}] ${item.title}”))\n}\n}\n}</p>\n<p>Now, whenever we want to render our UI based on the items we have, we can run the following:</p>\n<p>// render UI\nrenderNodeToScreen(compose { TodoApp(items) })</p>\n<p>With this new abstraction, it is also easy to pull out parts of our UI into smaller functions:</p>\n<p>fun Composer.TodoItem(item: TodoItem) {\nemit(Text(”[${if (item.completed) “x” else ” “}] ${item.title}”))\n}</p>\n<p>fun Composer.TodoApp(items: List<TodoItem>) {\nemit(Box()) {\nfor (item in items) {\nTodoItem(item)\n}\n}\n}</p>\n<p>This forms a solid mental model from which we can build on top of to understand R4A in greater detail.  The example above can be mapped to R4A directly, although it does not address problems (2) and (3) above, which R4A does and is explained in more detail further into this document.</p>\n<p>To transition into the syntax of R4A, let’s perform the following transformations in our head:</p>\n<p>The <code class=\"language-text\">Composer</code> receiver parameter we defined in the functions above is actually an implicit context object that the R4A compiler passes around for you. The type of this object is inferred with the <code class=\"language-text\">@Composable</code> annotation\nThe calls to other @Composable functions are done with a special syntax\nThe calls to <code class=\"language-text\">emit</code> on the <code class=\"language-text\">Composer</code> object are also done with the same special syntax</p>\n<p>Using these mappings, the example above can be rewritten to be:</p>\n<p>@Composable fun TodoItem(item: TodoItem) {\n&#x3C;Text text=”[${if (item.completed) “x” else ” “}] ${item.title}” />\n}</p>\n<p>@Composable fun TodoApp(items: List<TodoItem>) {\n<Box>\nfor (item in items) {\n<TodoItem item />\n}\n</Box>\n}</p>\n<p>// render UI\nrenderNodeToScreen(compose { <TodoApp items /> })</p>\n<p>As we can see from this example, there is an intentional duality between “emitting” a Node with certain attributes into the Composer and “calling” a function with some parameters which may then “emit” something into the Composer.</p>\n<p>We will use this mental model as a basis for understanding R4A. R4A introduces a concept called “Positional Memoization” which is a solution to the problems (2) and (3) posed above. We will talk about it in more detail below, but we will first delve into a few more concepts in the meantime.</p>\n<p>This forms a good solution to (1) above, but (2) and (3) are not yet solved. These problems are solved with R4A with Positional Memoization, but is not readily addressed with this simplistic model.</p>\n<p>We are going to discuss a few other concepts before jumping into Positional Memoization though.\nConcept: Positional Memoization\nSomeone performance conscious might look at the previous example we had and realize that we are creating a completely new tree every time we run <code class=\"language-text\">compose</code>. For large applications, this could create a lot of garbage. Furthermore, it means that if any of those nodes have any private state, the state will get thrown away.</p>\n<p>There are several ways one might go about fixing this, but R4A utilizes a technique called “Positional Memoization”. Much of R4A’s nuance is a result of this technique, so let’s try to build up a solid mental model of how it works.</p>\n<p>In the last section, we introduced a <code class=\"language-text\">Composer</code> object, which held some of the context of where in the tree we were and what node we were emitting into currently. Let’s add a cache of objects to the composer that is just a simple <code class=\"language-text\">List</code> data structure.  </p>\n<p>Most caches require keys, but a List’s only key is the index of the item itself. An alternative to keys is to assume that the cache will be asked the same set of “questions” the next time composition is run, and to rely on execution order directly. This means that you just need to ask the cache for what the item was last time, without providing any key, but asking the question will by its nature “progress” the cache forward.</p>\n<p>As a simple implementation of this, consider the following two methods being added to the <code class=\"language-text\">Composer</code> interface:</p>\n<p>interface Composer {\n// returns whether current cached item matches the passed in value. If it doesn’t,\n// it replaces it in the table. consumes item.\nfun <T> changed(value: T): Boolean</p>\n<p>   // return the current item in the cache, if <code class=\"language-text\">update</code> is true or the cache is\n// empty, run <code class=\"language-text\">factory</code>, cache and return result\nfun <T> cache(update: Boolean, factory: () -> T): T\n}</p>\n<p>A relatively simple implementation of this interface could be done like this:</p>\n<p>abstract class PositionalComposer : Composer {\nvar cache = mutableListOf&#x3C;Any?>()\nvar index = 0</p>\n<p>   override fun <T> changed(value: T): Boolean {\nval index = index++\nreturn if (cache.size &#x3C;= index) {\ncache[index] = value\nfalse\n} else {\nval item = cache[index]\ncache[index] = value\nitem != value\n}\n}</p>\n<p>   override fun <T> cache(update: Boolean, factory: () -> T): T {\nreturn if (update) factory().also { cache[index++] = it }\nelse cache[index++] as T\n}\n}</p>\n<p>With these primitive operations, one can create a more general purpose <code class=\"language-text\">memo</code> function:</p>\n<p>fun <T> Composer.memo(vararg inputs: Any?, factory: () -> T): T {\nvar valid = true\nfor (input in inputs) {\nvalid = !changed(input) &#x26;&#x26; valid\n}\nreturn cache(!valid) { factory() }\n}</p>\n<p>Note that <code class=\"language-text\">memo</code> will increment the cache index <code class=\"language-text\">n+1</code> times when it is called with <code class=\"language-text\">n</code> inputs. This means that it has the expectation that it will be called with the same number of inputs each time it is called for a given “position”, or else the cache will get misaligned.</p>\n<p>With this <code class=\"language-text\">memo</code> function, we are able to change our previous <code class=\"language-text\">TodoApp</code> example to now take advantage of memoization:</p>\n<p>fun Composer.TodoItem(item: TodoItem) {\nemit(\nmemo(item.completed, item.title) {\nText(”[${if (item.completed) “x” else ” “}] ${item.title}”)\n}\n)\n}</p>\n<p>fun Composer.TodoApp(items: List<TodoItem>) {\nemit(memo { Box() }) {\nfor (item in items) {\nTodoItem(item)\n}\n}\n}</p>\n<p>Now, every time we run <code class=\"language-text\">compose</code>, the nodes in the tree are reused unless they change. However, since we are using execution order to memoize, the amount of memory that we are using remains unchanged, and our programming model remains unchanged as well.</p>\n<p>In the current example, an entire node is memoized or not, but we can actually start to memoize individual properties of a node, provided they are mutable.</p>\n<p>For instance, consider the fact that <code class=\"language-text\">text</code> is a mutable property of <code class=\"language-text\">Text</code>:</p>\n<p>class Text(var text: String) : Node()</p>\n<p>Because of this, we can memoize all Text nodes, and just update the <code class=\"language-text\">text</code> attribute when it changes. To do this, we want a slightly different signature of <code class=\"language-text\">emit</code>:</p>\n<p>interface Composer {\nfun &#x3C;T: Node> emit(\nfactory: () -> T,\nupdate: (T) -> Unit,\nblock: () -> Unit = {}\n)\n}</p>\n<p>In this version of <code class=\"language-text\">emit</code>, we pass a <code class=\"language-text\">factory</code> function, which <code class=\"language-text\">emit</code> memoizes to create the <code class=\"language-text\">Node</code> itself. Then, the <code class=\"language-text\">update</code> function is called with the current <code class=\"language-text\">Node</code> instance. Inside of <code class=\"language-text\">update</code>, we can memoize the setting of the properties of it individually.</p>\n<p>For instance, the <code class=\"language-text\">TodoItem</code> component can be rewritten as:</p>\n<p>fun Composer.TodoItem(item: TodoItem) {\nval text = ”[${if (item.completed) “x” else ” “}] ${item.title}”\nemit(\n{ Text() },\n{ memo(text) { it.text = text }}\n)\n}</p>\n<p>So to enable optimum reuse, we can memoize each property individually, and reuse <code class=\"language-text\">Node</code> instances across every <code class=\"language-text\">compose</code> call. Syntactically, this approach starts to become a lot more cumbersome. This is why the KTX syntax encompasses this as part of its meaning. The above code snippet is equivalent to:</p>\n<p>@Composable fun TodoItem(item: TodoItem) {\n&#x3C;Text text=”[${if (item.completed) “x” else ” “}] ${item.title}” />\n}</p>\n<p>The keen reader might look at this and notice that there is a problem with this approach. This seems to break down when we change the size of the <code class=\"language-text\">items</code> list:</p>\n<p>@Composable fun TodoApp(items: List<TodoItem>) {\n<Box>\nfor (item in items) {\n<TodoItem item />\n}\n</Box>\n<Text text=\"Total: ${items.size} items\" />\n}</p>\n<p>In this example, if we had 2 items the first time the app composed, and 3 items the second time, what would happen?</p>\n<p>The first two items would memoize correctly, but when we encounter the third item, we would start to “memoize” on top of the <code class=\"language-text\">Text</code> node that is below the list of TodoItems! Essentially, any time there is any control-flow that causes the number of items cached in the list to change, everything after that conditional logic would be misaligned with the cache.</p>\n<p>To fix this, we need to introduce another fundamental concept to “Positional Memoization”: Groups.</p>\n<p>interface Composer {\n// start a group, execute block inside that group, end the group\nfun group(key: Any?, block: () -> Unit)\n}</p>\n<p>This concept complicates the implementation of the memoization cache of the composer, but it is critical for Positional Memoization to work correctly. Essentially, a group is what turns the linear cache into a tree-like structure, where we can then identify when nodes in that tree have been moved, removed, or added.</p>\n<p>It’s important to understand that the key itself of the group is only scoped to the immediate parent group, so there is no need for keys to be globally unique.  Now if we want to desugar our TodoApp example, we have something akin to:</p>\n<p>fun Composer.TodoItem(item: TodoItem) {\nval text = ”[${if (item.completed) “x” else ” “}] ${item.title}”\ngroup(3) {\nemit(\n{ Text() },\n{ memo(text) { it.text = text } }\n)\n}\n}</p>\n<p>fun Composer.TodoApp(items: List<TodoItem>) {\ngroup(0) {\nemit(memo { Box() }) {\nfor (item in items) {\ngroup(1) {\nTodoItem(item)\n}\n}\n}\n}</p>\n<p>   val text = “Total: ${items.size} items”\ngroup(2) {\nemit(\n{ Text() },\n{ memo(text) { it.text = text } }\n)\n}\n}</p>\n<p>In this case, we’ve just assigned unique integers as the keys to each group. Importantly, we’ve also surrounded the call to <code class=\"language-text\">TodoItem</code> with a group here, which will ensure that each TodoItem is memoized independently.</p>\n<p>Now, when the size of <code class=\"language-text\">items</code> changes from 2 to 3, we know to “add” items into the cache instead of look at the part of the cache that is ahead, since that would be outside of the group we are in. The same goes for cases where items are removed from the cache.</p>\n<p>Items that “move” are similarly handled, although the algorithm to do so is a bit more complex. We won’t be getting into this in detail, but the important bit to understand is that we track “moves” in a group based on the key of the child group.  If we shuffled the <code class=\"language-text\">items</code> list in this example, the fact that each TodoItem call is surrounded by a group with key <code class=\"language-text\">1</code> means that the Composer has no way of knowing that the order of the items changed. This isn’t fatal, it just means that the number of changes that are memoized is unlikely to be minimal, and any state that was associated with the item may now be associated with a different item. We could, however, use the <code class=\"language-text\">item</code> itself as the key:</p>\n<p>for (item in items) {\ngroup(item) {\nTodoItem(item)\n}\n}</p>\n<p>Now, each group and the contained set of cached values in that group will move along with the items, and then <code class=\"language-text\">TodoItem</code> will get called with the memoization cache of the same group from the previous compose, increasing the likelihood that the changes are minimal, with the cost of moving the cached items around.</p>\n<p>We will talk more later about these types of keys can manifest themselves automatically with Pivotal Attributes.</p>\n<p>As we can see here, there is quite a bit of ceremony around introducing new groups and keys manually for every single emit and call. Continuing the theme, the KTX element syntax also encompasses the creation of a group with a key. The key chosen is actually an integer that is computed from the unique position of the element in the source code. This is why we call it “Positional Memoization”: the memoization cache is keyed on the position of the element in source code, as well as the call graph. This means that, practically speaking, every element in the source code will have its own unique key that is part of its compilation. By using this position hash, we are able to leverage execution order for memoization while also allowing for conditional logic. </p>\n<p>With these groups incorporated into the syntax of a KTX element, we see that our example simplifies down into this:</p>\n<p>@Composable fun TodoApp(items: List<TodoItem>) {\n<Box>\nfor (item in items) {\n<TodoItem item />\n}\n</Box>\n<Text text=\"Total: ${items.size} items\" />\n}</p>\n<p>Concept: State\nThe examples so far have shown a UI that can be represented as a simple projection of data. The reality is that most UIs end up containing a number of stateful elements that don’t make any sense as part of the data model, but instead are specific to the UI itself (ie, “view state”).</p>\n<p>R4A’s state model might be best understood if we try and build it up from the concepts we’ve discussed so far with Positional Memoization.</p>\n<p>To discuss state, let’s change our example to a simple UI with a “count”, an “Increment” button, and a “Reset” button. To start out, we can imagine implementing this just using a global state object:</p>\n<p>var count = 0</p>\n<p>@Composable fun App(recompose: () -> Unit) {\n<Text text=\"$count\" />\n&#x3C;Button text=“Increment” onClick={ count++; recompose(); } />\n&#x3C;Button text=“Reset” onClick={ count = 0; recompose(); }/>\n}</p>\n<p>fun main() {\nvar recompose: () -> Unit = {}\nrecompose = {\nrenderNodeToScreen(compose { <App recompose /> })\n}\nrecompose()\n}</p>\n<p>Here we can see that the App component is using global state, which means that if this component is used in multiple places, the state will be shared across each usage. Though this can be useful in some situations, it’s usually not what we want. We want to be able to create an “instance” of count that can be used locally to the “instance” of App. </p>\n<p>How can we do this in R4A?</p>\n<p>The most basic thing to try is to move count into App as a local variable:</p>\n<p>// NOTE: This example does NOT work\n@Composable fun App(recompose: () -> Unit) {\nvar count = 0</p>\n   <Text text=\"$count\" />\n   <Button text=\"Increment\" onClick={ count++; recompose(); } />\n   <Button text=\"Reset\" onClick={ count = 0; recompose(); }/>\n}\n<p>This doesn’t work because the variable <code class=\"language-text\">count</code> will get re-initialized to zero every time the function gets invoked.</p>\n<p>Note that this is remarkably similar to how the nodes used to get recreated every time the function was called, but we utilized positional memoization to fix that. It turns out that here we can do the exact same thing!</p>\n<p>class State<T>(var value: T)</p>\n<p>@Composable fun App(recompose: () -> Unit) {\nval count = memo { State(0) }</p>\n   <Text text=\"${count.value}\" />\n   <Button text=\"Increment\" onClick={ count.value++; recompose(); } />\n   <Button text=\"Reset\" onClick={ count.value = 0; recompose(); }/>\n}\n<p>Now that we are using <code class=\"language-text\">memo</code>, the instance of <code class=\"language-text\">State</code> will be the same for every subsequent call of the function (but unique to its position in the UI tree). We can then mutate it and trigger a recomposition for the hierarchy so that the screen reflects the new value of the <code class=\"language-text\">State</code> instance.</p>\n<p>The above example suffers from the same problems that the memoizations of emits did before we introduced <code class=\"language-text\">group</code> calls around them. If we want to create state inside of control-flow logic, which we do, then we will need to do the same thing here. </p>\n<p>val count = group(123) { memo { State(0) } }</p>\n<p>This feels a bit tiresome to need to do this every time we want to introduce state, and it is also easy to forget and end up with incorrect code, so we have created a way of doing this that is less error-prone, that we call Effects.</p>\n<p>Effects are like bound composable function calls that are waiting to be “positionally called”, and the way you call them is with the <code class=\"language-text\">+</code> operator:</p>\n<p>class State<T>(var value: T)</p>\n<p>@Composable fun App(recompose: () -> Unit) {\nval count = +memo { State(0) }</p>\n   <Text text=\"${count.value}\" />\n   <Button text=\"Increment\" onClick={ count.value++; recompose(); } />\n   <Button; text=\"Reset\" onClick={ count.value = 0; recompose(); }/>\n}\n<p>The <code class=\"language-text\">+</code> operator, similar to the KTX element syntax, takes care of wrapping the call with a group and a key that is unique to the location of the call in source.</p>\n<p>As we will see later, Effects can be combined with observable @Model objects to make state really easy to work with in R4A, and remove some syntactic overhead, as well as ensure that a <code class=\"language-text\">recompose</code> function isn’t needed. Thus, our example just becomes:</p>\n<p>@Composable fun App() {\nvar count by +state { 0 }</p>\n   <Text text=\"$count\" />\n   <Button text=\"Increment\" onClick={ count++ } />\n   <Button text=\"Reset\" onClick={ count = 0 } />\n}",
      "fields": { "readingTime": { "text": "17 min read" } },
      "frontmatter": {
        "title": "Compose From First Principles",
        "date": "June 10, 2014"
      }
    }
  },
  "pageContext": {
    "slug": "/compose-from-first-principles/",
    "previous": {
      "fields": { "slug": "/one-concern-one-file/" },
      "frontmatter": { "title": "One Concern, One File" }
    },
    "next": null
  }
}
