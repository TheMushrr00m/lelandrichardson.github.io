{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "82f11951-da8a-57d5-8d42-e758d70e5fe6",
      "excerpt": "For some reason or another, it seems to me that SQL has always taken a back seat in the language economy.  I have used SQL for years, and…",
      "html": "<p>For some reason or another, it seems to me that SQL has always taken a back seat in the language economy.  I have used SQL for years, and very little has changed. </p>\n<p>After working on a couple of relatively large projects which use SQL quite a bit, I have slipped into a bit of a love-hate relationship with SQL.</p>\n<p>SQL has lot’s of beautiful features. SQL is already a fairly high-order language; a tremendous amount of implementation detail is left invisible to the programmer.  In terms of spewing data out of a data store, it can be impressively efficient.</p>\n<p>But somehow it just still isn’t quite <em>there</em>. Right?</p>\n<p>Most developers I know seem to avoid SQL like the plague… and that’s too bad.</p>\n<p>One day I started thinking about some of the specific hardships I’ve had with maintaining a large SQL codebase, and something dawned on me…</p>\n<p>Why hasn’t anyone created more convenient languages that transpile into SQL?  </p>\n<p>There is CoffeeScript, Dart, Typescript, etc for JavaScript.<br>\nThere is LESS and SCSS for CSS.</p>\n<p><strong>Why not something for SQL?</strong></p>\n<p>So I played the devil’s advocate and said: “What if SQL was a compile target?”</p>\n<p>In doing so, I found myself wanting a language that:</p>\n<ul>\n<li><strong>Strict superset of SQL.</strong> This is important because it promotes a clean transition. One can move migrate their SQL codebase incrementally since all valid SQL is also valid in this language.</li>\n<li><strong>Promotes good and efficient SQL practices</strong></li>\n<li><strong>Promotes keeping SQL code DRY</strong></li>\n<li><strong>Transpiles into easily readable SQL</strong></li>\n</ul>\n<p>For now I will call “BQL” for “A Better Query Language”.  I have taken a stab at outlining below a rough specification for what I think would be some positive features to add, while adhering to the constraints above.</p>\n<p>To summarize what I see as “benificial” to a language such as this, I would put as the following:</p>\n<h2>Key Language Benefits</h2>\n<ul>\n<li>notion of “projections” to keep SQL efficient, and keep code DRY</li>\n<li>inner joins are inferred with simplified syntax</li>\n<li>reordered select/from clauses to make autocomplete context more helpful</li>\n<li>queries can be stored syntactically and referenced in other statements to help readability, logical separation, and DRYness</li>\n<li>strict superset, so all SQL is already valid</li>\n<li>syntactic niceties with variable declaration / boolean logic / functions / etc.</li>\n</ul>\n<h2>Language Specification</h2>\n<hr>\n<h3>The <code class=\"language-text\">select</code> clause can be anywhere in a statement</h3>\n<p>In TSQL, the <code class=\"language-text\">select</code> clause of a select statement is done first, which makes it logically difficult to provide meaningful autocomplete suggestions for field names currently available in the context, since that is defined afterwards in the <code class=\"language-text\">from</code> and <code class=\"language-text\">join</code> clauses.</p>\n<p>In BQL, the <code class=\"language-text\">select</code> is valid at both the beginning and the end of the query.</p>\n<p>For example, the following BQL statements are equivalent:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from student\nwhere status = &#39;enrolled&#39;\nselect id, name, grade\n\n\nselect id, name, grade\nfrom student\nwhere status = &#39;enrolled&#39;</code></pre></div>\n<p>both of which will compile into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT \n    id, \n    name, \n    grade\nFROM student\nWHERE status = &#39;enrolled&#39;</code></pre></div>\n<h3>With the presence of foreign keys, join conditions are implied</h3>\n<p>Provided there is a single foreign key relationship defined unambiguously between two tables, the foreign key relationship is chosen implicitly as the default join condition.</p>\n<p>For instance, let’s say we have the following simplified tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE TABLE post (\n    id INT, -- primary key\n    /* ... */\n)\n\nDECLARE TABLE comment (\n    id INT, -- primary key\n    postId INT, -- foreign key to post.id\n    /* ... */\n)</code></pre></div>\n<p>The following BQL statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from post\ninner join comment\nselect *</code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *\nFROM post p\nINNER JOIN comment c\nON c.postId = p.id</code></pre></div>\n<p>When multiple tables are joined in a single statement, the table with which you want to join may become ambiguous, and an optional <code class=\"language-text\">with</code> clause can be added to the join:</p>\n<p>For instance, we may have the following tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE TABLE user (\n    id INT, -- primary key\n    /* ... */\n)\n\nDECLARE TABLE post (\n    id INT, -- primary key\n    authorId INT, -- foreign key\n    /* ... */\n)\n\nDECLARE TABLE comment (\n    id INT, -- primary key\n    postId INT, -- foreign key to post.id\n    authorId INT, -- foreign key to user.id\n    /* ... */\n)</code></pre></div>\n<p>then the following BQL statement</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from post\ninner join user u1 with post\ninner join comment\ninner join user u2 with comment\nselect *</code></pre></div>\n<p>compiles to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *\nFROM post p\nINNER JOIN user u1 \nON post.authorId = user.id\nINNER JOIN comment c \nON comment.postId = post.id\nINNER JOIN user u2 \nON comment.authorId = user.id</code></pre></div>\n<p>Furthermore, in some cases there are multiple foreign keys from one table to a single table. In this case, the join condition is ambiguous until you clarify which foreign key relationship you would like to use. As a result, one can use the <code class=\"language-text\">on</code> clause, however, unlike it’s SQL counterpart, only the column in the “foreign” table is needed.</p>\n<p>To demonstrate, provided we have the following tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE TABLE user (\n    id INT, -- primary key\n    /* ... */\n)\n\nDECLARE TABLE message (\n    id INT, -- primary key\n    senderId INT, -- foreign key with user.id\n    recipientid INT, -- foreign key with user.id\n    /* ... */\n)</code></pre></div>\n<p>Thus, the following BQL query:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from message m\ninner join user s on senderId\ninner join user r on recipientId\nselect *</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *\nFROM message m\nINNER JOIN user s ON m.senderId = s.id\nINNER JOIN user r ON m.recipientId = r.id</code></pre></div>\n<h3>Short-cutting Join Conditions in <code class=\"language-text\">where</code> clauses…</h3>\n<p>Joins are commonly used simply to perform a lookup and return the corresponding rows of one table. Provided there is a unique foreign key relationship between two tables, the lookup can be performed by a simple condition in the where clause like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from user \nwhere user:country.name = &#39;Canada&#39;\nselect id</code></pre></div>\n<p>which compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT u.id\nINNER JOIN country c\nON c.id = u.country_id\nWHERE c.name = &#39;Canada&#39; </code></pre></div>\n<p>Here the <code class=\"language-text\">{fk table name}:{pk table name}</code> syntax is used to identify the join while making the condition more easily legible. </p>\n<h3>Table Projections</h3>\n<p>Table projections are a construct in BQL which is not present in standard SQL.  A table projection is simply a named collection of field names which can be used (and thus re-used) in the select clause of any query.</p>\n<p>For instance, one can define a projection as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">projection [contact_info] {\n    firstName,\n    lastName,\n    phoneNumber,\n    email\n}</code></pre></div>\n<p>and thus, the BQL query</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from dbo.users\nselect &lt;contact_info&gt;</code></pre></div>\n<p>compiles into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    firstName,\n    lastName,\n    phoneNumber,\n    email\nFROM dbo.users</code></pre></div>\n<p>Further, I can mix selecting Projections and field names if needed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from dbo.users\nselect id, &lt;contact_info&gt;</code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    id,\n    firstname,\n    lastName,\n    phoneNumber,\n    email\nFROM dbo.users</code></pre></div>\n<p>The projection can be prefixed by the table name or table alias if you are projecting a specific table in a join…</p>\n<p>for instance, provided we have the following projections:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">projection abc { a, b, c }\n\nprojection def { d, e, f }</code></pre></div>\n<p>this BQL statement</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from tblX x\ninner join tblY y\non x.id = y.xid\nselect x.&lt;abc&gt;, y.&lt;def&gt;</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    x.a,\n    x.b,\n    x.c,\n    y.d,\n    y.e,\n    y.f\nFROM tblX X\nINNER JOIN tblY y\nON x.id = y.id</code></pre></div>\n<h3>The special <code class=\"language-text\">&lt;$all&gt;</code>, <code class=\"language-text\">&lt;$keys&gt;</code> Projection</h3>\n<p>Every table by default has an “include all” projection. This does not need to be defined anywhere, and is pragmatically equivalent to the ”*” operator in normal SQL, except for the fact that the compiled SQL will have all of the table’s fields enumerated explicitly in the compilation step.</p>\n<p>Given we have the following table definitions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">declare table abc (\n    id int, -- (primary key)\n    f1 int,\n    f2 varchar(20),\n    f3 datetime\n)\n\ndeclare table def (\n    id int PRIMARY KEY,\n    abcId int,  -- (foreign key to tbl1.id)\n    f4 varchar(20),\n    f5 datetime\n)</code></pre></div>\n<p>The following projections are implicitly created for these tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- for table &quot;abc&quot;\nprojection $all { id, f1, f2, f3 }\nprojection $keys { id }\n\n-- for table &quot;def&quot;\nprojection $all { id, abcId, f4, f5 }\nprojection $keys { id, abcId } </code></pre></div>\n<p>and thus, the following BQL statements:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from abc select &lt;$all&gt;\n\nfrom abc\ninner join def\non abc.id = def.abcId\nselect abc.&lt;$keys&gt;, def.&lt;$keys&gt;</code></pre></div>\n<p>compile into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    id,\n    f1,\n    f2,\n    f3\nFROM abc\n\nSELECT\n    abc.id,\n    def.id,\n    def.abcId\nFROM abc\nINNER JOIN def\nON abc.id = def.abcId</code></pre></div>\n<p>Similar to select lists, you can also specify computed columns as well as field name aliases</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">projection foo {\n    id as userId,\n    &#39;{{first}} {{last}}&#39; as displayName\n}</code></pre></div>\n<p>where the projection takes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from users\nselect &lt;foo&gt;</code></pre></div>\n<p>and compiles it into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    id as userId,\n    first + &#39; &#39; + last as displayName\nFROM users</code></pre></div>\n<p>Projection definitions can also reference other projections:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">projection fullName {\n    &#39;{{first}} {{last}}&#39; as fullName\n}\n\nprojection user {\n    id,\n    email,\n    &lt;fullName&gt;\n}</code></pre></div>\n<p>and thus:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from users\nselect &lt;user&gt;</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    id,\n    email,\n    first + &#39; &#39; + last as fullName\nFROM users</code></pre></div>\n<p>Notes about projections:</p>\n<ul>\n<li>they can be thought of as ad-hoc interfaces. They can be applied to any table, but will be a SQL compile error if the proper field names are not present on the table</li>\n<li>one can select multiple projections, comma delimited. in this case, common field names between the projections will be repeated… (or should they just be indicated once???)</li>\n<li>if projecting a table alias <code class=\"language-text\">a</code>, it would be <code class=\"language-text\">select a.&lt;contact_info&gt;</code></li>\n<li>if a delimited name is needed, it would be <code class=\"language-text\">select  &lt;[projection name]&gt;</code></li>\n<li>the above example uses another feature of BQL discussed below, string interpolation.</li>\n</ul>\n<h3>Boolean values first class citizens</h3>\n<p>BQL has <code class=\"language-text\">true</code> and <code class=\"language-text\">false</code> as new keywords which translate into a SQL <code class=\"language-text\">bit</code> data type.</p>\n<p>For instance, the following BQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">select true</code></pre></div>\n<p>Compiles into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @true BIT = 1;\n\nSELECT @true</code></pre></div>\n<p>If any statement contains usage of the boolean values <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code>, it will be transpiled into a local variable reference which is initialized at <code class=\"language-text\">1</code> or <code class=\"language-text\">0</code> accordingly.  This prevents some common ambiguities found between the <code class=\"language-text\">BIT</code> value of 1 and the <code class=\"language-text\">INT</code> value of 1.</p>\n<p>Further, many expressions are automatically converted into boolean expressions if evaluated in an <code class=\"language-text\">if</code> structure or a <code class=\"language-text\">where</code> clause.</p>\n<p>Note: more needs to be discussed on first-class suport of booleans in BQL.</p>\n<h3>Setting variables</h3>\n<p>no need for <code class=\"language-text\">SET</code>… ie, the line <code class=\"language-text\">@a = 1</code> => <code class=\"language-text\">SET @a = 1</code></p>\n<h3>Control-flow Logic</h3>\n<p>BQL introduces the usage of curly brackets as natural scope boundaries, similar to (but not equivalent to) SQL’s  <code class=\"language-text\">BEGIN ... END</code> syntax.</p>\n<h3>Brackets as scope boundaries</h3>\n<p>instead of <code class=\"language-text\">BEGIN ... END</code> we would have brackets. ie, </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if ( /* boolean expression */ ) { \n    /* expression */ \n} else {\n    /* expression\n}</code></pre></div>\n<h3>Variable declaration simplified…</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- implicit type\nvar @a = &#39;abc&#39;,\n    @b = 123\n\n-- explicit type\nvarchar(20) @a;\nint @b;\ndatetime @c;</code></pre></div>\n<p>Instead of:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @a VARCHAR(MAX) = &#39;abc&#39;\nDECLARE @b INT = 123\n\nDECLARE @a VARCHAR(20)\nDECLARE @b INT\nDECLARE @c DATETIME</code></pre></div>\n<h3>Better implicit type coercion…</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">print &#39;abc&#39; + 123  // prints &#39;abc123&#39;</code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">PRINT &#39;abc&#39; + CAST(123 AS VARCHAR)</code></pre></div>\n<p>Note: this should be thought about a little more. I like this, but it could actually cause existing (valid) SQL to break where the original intention different.</p>\n<h3>C-style <code class=\"language-text\">for</code> loops</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(int @i = 0; @i &lt; @length; @i++) {\n    /* expressions */\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @i INT = 0\nWHILE @i &lt; @length BEGIN\n\n    /* expressions */\n\n    SET @i = @i + 1\nEND</code></pre></div>\n<h3>C# style foreach</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foreach(var @row in users) {\n    if( @row.id % 2 ) {\n        print &#39;{{row.first}} {{row.last}}&#39;\n    }\n\n    /* expressions */\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @id INT,\n        @first VARCHAR(50),\n        @last VARCHAR(50)\n\nDECLARE cursor_1 CURSOR FOR\nSELECT\n    id,\n    first,\n    last\nFROM users\n\nOPEN cursor_1;\n\nFETCH NEXT FROM cursor_1\nINTO @id, @first, @last;\n\nWHILE @@FETCH_STATUS = 0\nBEGIN \n    IF NOT( @id % 2 = 0 ) BEGIN\n        PRINT @first + &#39; &#39; + @last\n    END \n\n    /* expressions */\n\n    FETCH NEXT FROM cursor_1\n    INTO @id, @first, @last;\nEND\n\nCLOSE cursor_1;\nDEALLOCATE cursor_1;</code></pre></div>\n<p>Note: might want to talk about how this promotes precedural flow in SQL which isn’t necessarily a good thing…</p>\n<h3>String interpolation</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @name = &#39;john doe&#39;\n\n-- prints &#39;my name is john doe&#39;\nprint &#39;my name is: {{name}}&#39; </code></pre></div>\n<p>Note: we could adopt something different than this sort of “mustache-style” here. We might want to think more about this.  This is also potentially the most obvious breach of being a “strict superset” of SQL.</p>\n<h3>Local scoping rules</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @i = 1;\n\nif (true)  { // new variable scope...\n    var @i = 2;\n\n    print @i // prints 2\n}\n\nprint @i // prints 1</code></pre></div>\n<p>this would compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @true BIT = 1,\n        @i INT = 1,\n        @i_two INT;\n\nIF (@true = @true) BEGIN\n    SET @i_two = 1;\n\n    PRINT @i_two;\nEND\n\nPRINT @i</code></pre></div>\n<p>you can also declare local scope by just writing code inside brackets:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    -- in this scope, @i is an int\n    var @i = 123;\n}\n{\n    -- in this scope, @i is of type varchar\n    var @i = &#39;abc&#39;\n}</code></pre></div>\n<h3>Ternary operator</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">select @a &gt; @b ? &#39;123&#39; : &#39;456&#39;</code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT CASE WHEN @a &gt; @b THEN &#39;123&#39; ELSE &#39;456&#39; END</code></pre></div>\n<h3>Null coalescing operator</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from students\nselect name ?? &#39;N/A&#39;</code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT ISNULL(name, &#39;N/A&#39;)\nFROM students</code></pre></div>\n<h3>Boolean operators</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if ( (@a || @b) &amp;&amp; !@c) {\n    /* expressions */\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @true BIT = 1,\n        @false BIT = 0;\n\nIF ( (@a = @true OR @b = @true) AND @c = @false ) BEGIN\n    /* expressions */\nEND</code></pre></div>\n<h3>Method notation on various datatypes</h3>\n<p>various datatypes would have various “methods” defined for them which simply compile into calls for the global method…</p>\n<p>for instance, everything would have a <code class=\"language-text\">.toString()</code> method…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @i = 1234;\nvar @s = &#39; AbcdEf &#39;;\ndatetime @d = GETUTCDATE();</code></pre></div>\n<h4>Methods for <code class=\"language-text\">char</code>, <code class=\"language-text\">varchar</code>, <code class=\"language-text\">nchar</code>, and <code class=\"language-text\">nvarchar</code></h4>\n<ul>\n<li>trim()</li>\n<li>ltrim()</li>\n<li>rtrim()</li>\n<li>toLowerCase()</li>\n<li>toUpperCase()</li>\n<li>toTitleCase() - not sure this is possible/practical</li>\n<li>padLeft()</li>\n<li>padRight()</li>\n<li>pad()</li>\n<li>contains(string s)</li>\n<li>endsWith(string s)</li>\n<li>startsWith(string s)</li>\n<li>substring</li>\n<li>split(string seperator) - this would return a table… could be interesting</li>\n<li>toCharSet() - not sure if this is possible/practical, but could be a cool feature as well.</li>\n<li>indexOf()</li>\n</ul>\n<p>calling methods on variables would work pretty much how you would expect:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@s.trim()</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">LTRIM(RTRIM(@s))</code></pre></div>\n<p>and so on…</p>\n<h4>Methods for <code class=\"language-text\">datetime</code> and <code class=\"language-text\">date</code></h4>\n<ul>\n<li>addDays(numerical d)</li>\n<li>addHours(numerical d)</li>\n<li>addMinutes(numerical d)</li>\n<li>addMilliseconds(numerical d)</li>\n<li>addMonths(numerical d)</li>\n<li>addSeconds(numerical d)</li>\n<li>addTicks(numerical d)</li>\n<li>addYears(numerical d)</li>\n<li>toOADate()</li>\n<li>toString(string format)</li>\n<li>subtract(datetime d) - need to think about this more… how is a timespan represented in SQL?</li>\n<li>add(datetime d)</li>\n<li>dayOfMonth()</li>\n<li>dayOfYear()</li>\n<li>dayOfWeek()</li>\n<li>hour()</li>\n<li>minute()</li>\n<li>millisecond()</li>\n<li>ticks()</li>\n<li>second()</li>\n<li>year()</li>\n<li>date()</li>\n</ul>\n<p>note: i’d like to think more about functionality that can be had around UTC time / local time conversion and such. Could be a big win for this language if implemented in a way that prevented people from doing bad practices…</p>\n<h4>Methods on <code class=\"language-text\">int</code>, <code class=\"language-text\">bigint</code>, <code class=\"language-text\">tinyint</code>, <code class=\"language-text\">decimal</code>, <code class=\"language-text\">float</code></h4>\n<ul>\n<li>toString(string format)</li>\n</ul>\n<h3>Datetime declaration</h3>\n<p>a convention for declaring date times will exist, but i’m not sure on the syntax.</p>\n<p>could be: <code class=\"language-text\">var @dt = #1/12/2014#</code>  (this is kind of similar to an MS Access convention).</p>\n<p>could also be <code class=\"language-text\">var @dt = &amp;&#39;1/12/2014&#39;</code></p>\n<h3>Regular expressions</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @a = /(s|o)me?reg[ular]ex[pression]/.replace(&#39;abcd&#39;,&#39;&#39;);\nvar @islower = !/[A-Z]/.match(@test);</code></pre></div>\n<p>Note: I’d like to do more thinking here on how we could bring more native support to regular expressions to SQL. This will largely depend on the target (ie, T-SQL, PL/SQL, etc.)</p>\n<h3>Explicit type casting</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">select (varchar)123</code></pre></div>\n<p>compiles into\n<br>\nselect CAST(123 as VARCHAR)</p>\n<h3><code class=\"language-text\">+=</code> and <code class=\"language-text\">-=</code> operators</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @i = 1,\n    @s = &#39;abc&#39;;\n\n@i += 1\n@s += &#39;def&#39;</code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @i INT = 1,\n        @s varchar = &#39;abc&#39;;\n\nSET @i = @i + 1;\nSET @s = @s + &#39;def&#39;;</code></pre></div>\n<h3>Paging syntax</h3>\n<p>The <code class=\"language-text\">offset</code> and <code class=\"language-text\">limit</code> keywords will be used for paging, and will\nsatisfy all SQL targets appropriately.</p>\n<p>For instance: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from tbl\norder by a\nselect a, b, c\noffset 100\nlimit 20</code></pre></div>\n<p>for SQL Server 2008 would compile into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">;WITH tbl_paged AS\n(\n    SELECT\n        a,\n        b,\n        c,\n        ROW_NUMBER() OVER (ORDER BY a ASC) as __row_number\n    FROM tbl\n)\nSELECT\n    a,\n    b,\n    c\nFROM tbl_paged\nWHERE __row_number BETWEEN 100 AND 100 + 20</code></pre></div>\n<p>Versus MySQL where it would simply compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    a,\n    b,\n    c\nFROM tbl\nOFFSET 100\nLIMIT 20</code></pre></div>\n<p>Of course, we are also able to use variables or scalar expressions here</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">from tbl\norder by a\nselect a, b, c\noffset (@page - 1) * @size\nlimit @size</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">;WITH tbl_paged AS\n(\n    SELECT\n        a,\n        b,\n        c,\n        ROW_NUMBER() OVER (ORDER BY a ASC) as __row_number\n    FROM tbl\n)\nSELECT\n    a,\n    b,\n    c\nFROM tbl_paged\nWHERE __row_number BETWEEN (@page - 1) * @size + 1 AND @page * @size</code></pre></div>\n<p>NOTE: the compilation of these keywords would be different depending on the target… different SQL engines have different support for paging already.</p>\n<h3>Implicit “result sets” as local variables</h3>\n<p>Result set variables can be declared as you would any other query select statement</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @results = from tbl1 select a, b, c where a &lt; 20;</code></pre></div>\n<p>Result set variables have a couple of unique properties that temp tables and table variables do not have…</p>\n<p>For example, you can…</p>\n<h4>Coerce a resultset variable into a boolean as a shortcut for <code class=\"language-text\">EXISTS</code></h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @results = from tbl1 select a, b, c where a &lt; 20;\n\nif (@results) {\n    /* expressions */\n}</code></pre></div>\n<p>this will compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @results TABLE (\n            a INT, \n            b VARCHAR(20), \n            c VARCHAR(255)\n        )\n\nINSERT INTO @results ( a, b, c )\nSELECT \n    a, \n    b, \n    c \nFROM tbl1 \nWHERE a &lt; 20\n\nIF EXISTS(SELECT TOP 1 * FROM @results)\nBEGIN\n    /* expressions */\nEND</code></pre></div>\n<h4>Get a resultset variable’s number of rows</h4>\n<p>calling a <code class=\"language-text\">.length</code> method on a resultset variable is shorthand for getting the total count</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @results = from tbl1 select a, b, c where a &lt; 20;\n\nvar @count = @results.length</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DECLARE @results TABLE (\n            a INT, \n            b VARCHAR(20), \n            c VARCHAR(255)\n        )\nDECLARE @count INT\n\nINSERT INTO @results ( a, b, c )\nSELECT \n    a, \n    b, \n    c \nFROM tbl1 \nWHERE a &lt; 20\n\nSELECT @count = COUNT(*)\nFROM @results</code></pre></div>\n<p>in certain cases where a resultset variable can be optimized into a CTE, it will do so.  This is the case when the query is referenced in only one statement.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @results = from tbl1 select a, b, c where a &lt; 20;\n\n-- here we only use results in *one* statement\nfrom @results\nwhere a &gt; 10\nselect a, b, c</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">;WITH results AS\n(\n    SELECT\n        a,\n        b,\n        c\n    FROM tbl1\n    WHERE a &lt; 20\n)\nSELECT\n    a,\n    b,\n    c\nFROM results\nWHERE a &gt; 10</code></pre></div>\n<p>note: some of the above examples would also allow and utilize this optimization, but the compiled output shown is that of the more general case (table variables) simply for clarity of what would normally happen.\n<br>\nIn other cases, the resultset variable will be created as a table variable</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @results = from tbl1 select a, b, c where a &lt; 20;\n\nvar @count = @results.length</code></pre></div>\n<h3>Resultsets as partial queries</h3>\n<p>Resultset variables can be useful in taking complex queries and compartmentalizing them into digestable parts without sacrificing performance by storing the results into temp tables, or going through the unnecessary overhead of creating a view to be used just once:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-- notice how no &quot;select&quot; clause is needed here...\nvar @unpaid_cust = from customers where status = &#39;unpaid&#39;\n\nfrom invoices i \ninner join @unpaid_cust\nwhere i.date_sent != null\nselect invoices.&lt;$all&gt;</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    i.id,\n    i.field1,\n    /* ... */\nFROM invoices i\nINNER JOIN customers c\nON i.customer_id = c.id\nWHERE \n    c.status = &#39;unpaid&#39; AND\n    i.date_sent IS NOT NULL</code></pre></div>\n<p>Although this is a smple example, it should be clear how you can take a very complex query with several joins and partialize it into logically separate pieces, letting BQL compile it into one final efficient query.</p>\n<h3>Mixins: Inline Functions</h3>\n<p>simple inline functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @postUrl = mixin(@id, @slug) {\n    return &#39;http://tech.pro/post/{{@id}}/{{slug}}&#39;\n}\n\n\nfrom post\nselect id, @postUrl(id,slug) as url</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    id,\n    &#39;http://tech.pro/post/&#39; + CAST(id as varchar) + &#39;/&#39; + slug\nFROM posts</code></pre></div>\n<p>or…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var @isEmail = mixin(@email){\n    return @email.contains(&#39;@&#39;)\n}\n\nfrom users\nwhere @isEmail(email)\nselect id, email</code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT id, email\nFROM users\nWHERE CHARINDEX(&#39;@&#39;,email) &gt; 0</code></pre></div>\n<h3>Schema scope declaration</h3>\n<p>you can use a schema scope declaration in order to default to certain databases and schema</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">schema abc {\n\n    from tbl1\n    select a, b, c\n}</code></pre></div>\n<p>compiles to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n    a,\n    b,\n    c\nFROM abc.tbl1</code></pre></div>\n<p>if no schema scope is used, the schema will instead be the database default schema. This is essentially like locally “overriding” the database default schema…</p>\n<h3>Some ideas I haven’t thought through yet…</h3>\n<ol>\n<li>\n<p>support for more complicated aggregate functions?  For example a <code class=\"language-text\">JOIN</code> or <code class=\"language-text\">CSV</code> aggregate function based on the XML expand functionality.</p>\n</li>\n<li>\n<p>what about boolean logic w/ nulls?  could we allow <code class=\"language-text\">if (field_name = null)</code> in replacement of <code class=\"language-text\">IF (field_name IS NULL)</code>?</p>\n</li>\n<li>\n<p>We could have some javascript-like type coersion?  For example, could <code class=\"language-text\">!field_name</code> be converted to <code class=\"language-text\">field_name is null OR field_name = &#39;&#39;</code> and similar tests?</p>\n</li>\n</ol>\n<h3>Next steps…</h3>\n<p>Languages are complicated things, and I think in order to be successful, must be the product of many minds.  I’d like for any and all feedback (or help) on producing this language spec, as well as a parser/compiler for it.  If you stumbles upon this article because you have similar wishes for such a language to exist, please consider contributing.</p>\n<p>I’ve opened a <a href=\"https://github.com/lelandrichardson/BQL\">GitHub repo</a> where I’ve started work on the parser and grammar. Right now I’m trying out <a href=\"http://irony.codeplex.com/\">Irony</a> to build an AST, as it makes building into the Visual Studio toolchain very easy, but the Irony grammar is very easy to translate into BNF if we want to try other AST Parsers as well.</p>\n<p><strong>At the very least, share your opinions below.</strong></p>\n<p>Thank you.</p>",
      "fields": { "readingTime": { "text": "19 min read" } },
      "frontmatter": {
        "title": "Just text and links",
        "date": "December 25, 2018"
      }
    }
  },
  "pageContext": {
    "slug": "/a-better-query-language-bql-language-specification/",
    "previous": {
      "fields": {
        "slug": "/3-tricks-to-get-more-out-of-sql-server-in-common-web-scenarios/"
      },
      "frontmatter": { "title": "" }
    },
    "next": null
  }
}
