{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "f4079b46-ae61-566d-a945-abccb0878c2c",
      "excerpt": "KnockoutJS  provides the plumbing to create very powerful web applications, but leaves most of the logic up to the developer.  That’s great…",
      "html": "<p><a href=\"http://knockoutjs.com/\">KnockoutJS</a> provides the plumbing to create very powerful web applications, but leaves most of the logic up to the developer.  That’s great, and I don’t think it should be any different, but developers need to look out for common use case scenarios where there is often the potential to be a lot of duplicated boiler-plate code.  One such case (I have found) is creating paged datasets.</p>\n<h2>The Simple Case</h2>\n<p>Say I just have an array of simple JS/JSON objects, all I want to do is build a <code class=\"language-text\">ko.computed</code> computed observable that simply pulls out the slice of the array that represents the current “page”.</p>\n<p>Simple. Someone reasonably adept at knockout can knock that out pretty quickly.</p>\n<p>Starting with our viewmodel (which in my examples will follow a constructor pattern, however this does not have to be the case):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var ExampleViewModel = function(data){\n    \n    // ...  \n    // other viewmodel data we don&#39;t care about\n    // ...\n\n    // the array of items that I want to page\n    this.items = ko.observableArray(data);\n\n};</code></pre></div>\n<p>Cool. Okay, well I have my viewmodel here… I might as well start slamming some observables related to my pager on there!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var ExampleViewModel = function(data){\n    // stuff that matters\n    // ---------------------------------------------\n    this.items = ko.observableArray(data);\n\n    // pager related stuff\n    // ---------------------------------------------\n    this.currentPage = ko.observable(1);\n    this.perPage = 10;\n    this.pagedItems = ko.computed(function(){\n        var pg = this.currentPage(),\n            start = this.perPage * (pg-1),\n            end = start + this.perPage;\n        return this.items().slice(start,end);\n    }, this);\n    this.nextPage = function(){\n        if(this.nextPageEnabled())\n            this.currentPage(this.currentPage()+1);\n    };\n    this.nextPageEnabled = ko.computed(function(){\n        return this.items().length &gt; this.perPage * this.currentPage();\n    },this);\n    this.previousPage = function(){\n        if(this.previousPageEnabled())\n            this.currentPage(this.currentPage()-1);\n    };\n    this.previousPageEnabled = ko.computed(function(){\n        return this.currentPage() &gt; 1;\n    },this);\n};</code></pre></div>\n<p>And there ya have it.  A pager in Knockout.JS. Wiring it up to the view is somewhat trivial:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;ul class=&quot;pager&quot;&gt;\n    &lt;li data-bind=&quot;css: {&#39;disabled&#39;: !previousPageEnabled()}&quot;&gt;\n        &lt;a href=&quot;#&quot; data-bind=&quot;click: previousPage&quot;&gt;Previous&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li data-bind=&quot;css: {&#39;disabled&#39;: !nextPageEnabled()}&quot;&gt;\n        &lt;a href=&quot;#&quot; data-bind=&quot;click: nextPage&quot;&gt;Next&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;</code></pre></div>\n<iframe style=\"width:100%;height:520px;\" src=\"http://jsfiddle.net/lelandrichardson/yuvNt/embedded/result,js,html\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<br>\n<p>This is a relatively simple result to accomplish with knockout… but if you feel like this is a little bit lacking, you are not alone.  The problem is there is just a bunch of logic up there that just shouldn’t matter to us.  This is not really business logic… it is a common UI implementation that has nothing to do with the core of our application - so I don’t want to look at it!  More than that, I have just added a bunch of properties to my viewmodel which might end up getting serialized to JSON and sent to my server, which I don’t want.</p>\n<p>Even more, this is about <em>as simple</em> as your situation will possibly be.  Chances are, you are probably wanting to do something more complicated, like pull data from the server asynchronously via ajax…  In this case, these methods are going to get more and more complicated, making our viewModel even more messy!</p>\n<h2>Getting DRY</h2>\n<p>Nevermind loading data via AJAX for a moment.  Let’s just get this thing out of our viewmodel.</p>\n<p>In order to do this, we are going to extend the prototype of <code class=\"language-text\">ko.observableArray</code>.  This feels appropriate, since we are typically going to want to page an array, and our viewModel might have several arrays, each of which need to be paged.  This has a slight limitation in that it prevents us from creating a paged array around a plain old JS array (ie, only works on a <code class=\"language-text\">ko.observableArray</code>), but I am okay with that right now.</p>\n<p>So, we rework our code a bit and come up with this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ko.observableArray.fn.paged = function(perPage){\n    var items = this;\n\n    items.current = ko.observable(1);\n    items.perPage = perPage;\n    items.pagedItems = ko.computed(function(){\n        var pg = this.current(),\n            start = this.perPage * (pg-1),\n            end = start + this.perPage;\n        return this().slice(start,end);\n    }, items);\n\n    items.next = function(){\n        if(this.next.enabled())\n            this.current(this.current()+1);\n    }.bind(this);\n\n    items.next.enabled = ko.computed(function(){\n        return this().length &gt; this.perPage * this.current();\n    },items);\n\n    items.prev = function(){\n        if(this.prev.enabled())\n            this.current(this.current()-1);\n    }.bind(this);\n\n    items.prev.enabled = ko.computed(function(){\n        return this.current() &gt; 1;\n    },items);\n\n\n    return items;\n};</code></pre></div>\n<p>All of the code here is essentially the same as before.  The main difference here is that we are now hanging all of our pager methods off of the actual <code class=\"language-text\">ko.observableArray</code> instance, instead of our viewModel directly.  <strong>Remember, this is possible because an instance of <code class=\"language-text\">ko.observableArray</code> is actually just a function.  And functions can have properties just like any other object in JavaScript!</strong></p>\n<p>This results in the functionally equivalent, but a <em>much</em> cleaner viewmodel:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var ExampleViewModel = function(){\n    this.items = ko.observableArray().paged(10);\n};</code></pre></div>\n<p>And the modified HTML:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;ul class=&quot;pager&quot;&gt;\n    &lt;li data-bind=&quot;css: {&#39;disabled&#39;: !items.prev.enabled()}&quot;&gt;\n        &lt;a href=&quot;#&quot; data-bind=&quot;click: items.prev&quot;&gt;Previous&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li data-bind=&quot;css: {&#39;disabled&#39;: !items.next.enabled()}&quot;&gt;\n        &lt;a href=&quot;#&quot; data-bind=&quot;click: items.next&quot;&gt;Next&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;</code></pre></div>\n<p><a href=\"http://jsfiddle.net/lelandrichardson/BnYMW/\">See jsFiddle Example</a></p>\n<p>But of course, we do gain some other benefit of the added abstraction: the benefit of being DRY. For example, we could have multiple paged arrays in the same View Model if we wanted without sharing any state!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Example = function(){\n    this.apples = ko.observableArray().paged(10);\n    this.oranges = ko.observableArray().paged(20);\n};</code></pre></div>\n<h2>Handling The More Common Case: Lazy-Loaded paged data-sets via AJAX</h2>\n<p>Paged lists are nothing new.  Turns out there is lots of data on the internet, and it often times is not economical or practical to display it to the user all at once.</p>\n<p>The example above helps us stay DRY, but only helps us in the cases where we have all of the data already on the client.  Although this is helpful some of the time, a much more practical scenario is when we have a (potentially) large dataset that is being stored on the server (likely in a database), and we want to display results to the user querying it, but we obviously don’t want the client to have to download all of the data at once!</p>\n<p>So although the code above is a fun little exercise, it is hard to really say that it is useful.  I like useful things, so let’s take another stab at it.</p>\n<h2>Being useful: handle any case</h2>\n<p>So we don’t want to just rewrite the above code to work asynchronously, but forget the static case altogether! Let’s provide an API that is flexible enough to let the user (read: developer) decided how he/she wants the pager to behave.</p>\n<p>To demonstrate this, I am merely going to provide some of the key snippets.  The code here is getting a bit lengthier and the point is lost with boiler-plate logic.</p>\n<p>When loading data asynchronously, you want to minimize trips to the server, so we must store whether or not we have retrieved a certain page or not.  To do this, we create a local array called <code class=\"language-text\">loaded</code> which is an array of booleans. Thus, to check if the 5th page has been loaded, we simply see if <code class=\"language-text\">loaded[5] === true</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var loaded = [true]; // set [0] to true just because.\n\nvar goToPage = function(pg){\n    if(loaded[pg]){\n        //data is already loaded. change page asynchronously to simulate a *really fast* ajax call\n        isLoading(true);\n        setTimeout(function(){\n            current(pg);\n            isLoading(false);\n        },0);\n    } else {\n        // request data from server\n        $.get(&#39;/path/to/server?pg=&#39; + pg, function(res){\n            onPageReceived(pg,res); // handle server response\n            isLoading(false);\n        });\n    }\n};\n\nvar onPageReceived = function(pg,data){\n    // append data to items array (in correct spot)\n    var start = cfg.pageSize*(pg-1);\n        data.unshift(start,0);\n    Array.prototype.splice.apply(items(),data);\n    items.notifySubscribers();\n\n    loaded[pg] = true; // indicate this page has been loaded\n    current(pg); // change current page\n};</code></pre></div>\n<p>The devil might be in the details, but this demonstrates the main mechanics of it all.  The key things to note here are:</p>\n<ol>\n<li>\n<p><code class=\"language-text\">.push</code> is not used to add items to the array.<br/> This is because <code class=\"language-text\">.push</code> adds elements to the end of an array.  Since we are lazy loading, we may end up loading page 3 before we have page 2.  In this scenario we need to add elements to the correct index on the array.  It’s kind of messed up that JavaScript arrays let you do this… but that’s another discussion in and of itself.</p>\n</li>\n<li>\n<p>even when we have the data, <code class=\"language-text\">setTimeout</code> is used.<br/>This is a rather important principle when writing code for others to use: <strong>Don’t write methods that are asynchronous or synchronous only part of the time.</strong> By using <code class=\"language-text\">setTimeout</code> we are effectively emulating an AJAX call that is just really fast.  This allows the user to write code against the <code class=\"language-text\">.goToPage()</code> method in a consistent way.</p>\n</li>\n<li>\n<p>the <code class=\"language-text\">items.notifySubscribers()</code> call is required here.<br/> This is because we are using the array <code class=\"language-text\">.splice</code> method on the underlying array in order to add data to it.  Because we are unwrapping the observable to do this (and never calling the setter method, or any of the special <code class=\"language-text\">ko.observableArray</code> methods), knockout doesn’t know that the array has changed.  To let knockout know that the data  has changed, we call the <code class=\"language-text\">.notifySubscribers()</code> method.</p>\n</li>\n</ol>\n<p>Although this works, you may have noticed it only works for asynchronously-loaded datasets, and doesn’t allow for much configuration.  Building configurable API’s adds a considerable amount of code, and thus I have removed it above.</p>\n<p>I did, however, take the time to build a first-version of a knockout plugin <a href=\"https://github.com/lelandrichardson/knockout-paged\">which I have put on github</a>. It allows for the flexibility that I was calling for above, and used the above code as a starting point.</p>\n<p>For this plugin, one calls it in an almost identical fashion to the examples above.  The API is as follows:</p>\n<h3>What is returned?</h3>\n<p>When calling <code class=\"language-text\">.paged</code> on a <code class=\"language-text\">ko.observableArray</code> instance, the result is the same observable array, augmented with several different paging-related properties which are added to the observableArray itself (not the underlying array).</p>\n<p>The following properties are added:</p>\n<ul>\n<li><code class=\"language-text\">current</code> (<em>Type:</em> <code class=\"language-text\">ko.observable(Number)</code> ) <br/> An observable of the current page number (starting from 1)</li>\n<li><code class=\"language-text\">pagedItems</code> (<em>Type:</em> <code class=\"language-text\">ko.observableArray</code> ) <br/> An observable array containing only the items of the current page. (ie, the “paged items”)</li>\n<li><code class=\"language-text\">pageSize</code> (<em>Type:</em> <code class=\"language-text\">Number</code> ) <br/> The integer value of the page size (default is 10)</li>\n<li><code class=\"language-text\">isLoading</code> (<em>Type:</em> <code class=\"language-text\">ko.observable(Boolean)</code> ) <br/> An observable indicating whether or not data is currently being retrieved from the server (only ever true for Ajaxified datasets)</li>\n<li><code class=\"language-text\">next</code> (method) <br/> If enabled, loads the next page.</li>\n<li><code class=\"language-text\">previous</code> (method) <br/> If enabled, loads the previous page.</li>\n<li><code class=\"language-text\">goToPage</code> (method(<code class=\"language-text\">Number</code>)) <br/> Goes to the designated page. (Indexed starting at 1)</li>\n</ul>\n<p>The paged observable array can be created by using one of the three different method signatures:</p>\n<h3>Page locally available data easily</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// data is already loaded on the client\n.paged(Number pageSize) =&gt; ko.observableArray (self)</code></pre></div>\n<ul>\n<li><code class=\"language-text\">pageSize</code> : A <code class=\"language-text\">Number</code> (Integer expected) indicating the desired page size for the observable array</li>\n<li><strong>returns</strong> : The <code class=\"language-text\">ko.observableArray</code> instance that <code class=\"language-text\">.paged</code> was called on, augmented with the paging methods</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var ExampleViewModel = function(){\n    this.apples = ko.observableArray().paged(10);\n    \n    //... data can be loaded at any time\n    this.apples.push({type: &#39;Jazz&#39;, state: &#39;Ripe&#39;});\n};</code></pre></div>\n<h3>Page server-side dataset with Url Template</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// data is to be loaded via ajax, with a regular URL structure\n.paged(Number pageSize, String templateUrl) =&gt; ko.observableArray (self)</code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">pageSize</code> : A <code class=\"language-text\">Number</code> (Integer expected) indicating the desired page size for the observable array</p>\n</li>\n<li>\n<p><code class=\"language-text\">templateUrl</code> : A <code class=\"language-text\">String</code> representing the URL template to be used to grab the data from the server.</p>\n</li>\n<li>\n<p><strong>returns</strong> : The <code class=\"language-text\">ko.observableArray</code> instance that <code class=\"language-text\">.paged</code> was called on, augmented with the paging methods</p>\n</li>\n</ul>\n<p>Example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Example = function(){\n    // apples is empty. will automatically load first page, and any other page which is requested\n    // by using the provided url template\n    this.apples = ko.observableArray().paged(10,&#39;/url/to/get/apples?page={page}&amp;pageSize={pageSize}&#39;);\n};</code></pre></div>\n<h3>Configure it to do what you need with options hash</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.paged(Object config) =&gt; ko.observableArray (self)</code></pre></div>\n<p>In this case we simply pass in an object hash with whatever options we want to set.  The following options are made available:</p>\n<table class=\"table table-bordered\">\n    <tr>\n        <th>Name</th>\n        <th>Type</th>\n        <th>Type</th>\n    </tr>\n    <tr>\n        <td><code>pageSize</code></td>\n        <td><code>Number</code></td>\n        <td>The desired page size. Expected to be an integer</td>\n    </tr>\n    <tr>\n        <td><code>async</code></td>\n        <td><code>Boolean</code></td>\n        <td>\n            Whether or not the dataset will be loaded asynchronously or not.  \n            Note: this may be overridden if async-only options are provided when this is set to \n            false or vice-versa.\n        </td>\n    </tr>\n    <tr>\n        <td><code>url</code></td>\n        <td><code>String</code></td>\n        <td>\n            A string template for a URL optionally containing any of the following formatters: <code>{page}</code>, <code>{pageSize}</code>, <code>{start}</code>, <code>{end}</code> which will then be replaced with the corresponding data.  For example, <code>'/resource/list/start/{start}/end/{end}'</code> will produce <code>'/resource/list/start/0/end/10'</code> on initialization with default options. <b>Note: async only</b>\n        </td>\n    </tr>\n    <tr>\n        <td></td>\n        <td><code>Function</code></td>\n        <td>\n            A function which will be expected to receive a single parameter which is an object hash containing the properties <code>page</code>, <code>pageSize</code>, <code>start</code>, <code>end</code>, and return the to be requested to get the corresponding page of data. <b>Note: async only</b>\n        </td>\n    </tr>\n    <tr>\n        <td><code>cache</code></td>\n        <td><code>Boolean</code></td>\n        <td>\nBoolean representing whether or not the data retrieved from the server should be reused the next time the page is requested.  Default is <code>true</code> <b>Note: async only</b>\n        </td>\n    </tr>\n    <tr>\n        <td><code>mapFromServer</code></td>\n        <td><code>Function</code></td>\n        <td>\nA callback function which is called on AJAX success with the AJAX response as the only parameter.  The callback is expected to return the array to be the current page. <b>Note: async only</b>\n        </td>\n    </tr>\n    <tr>\n        <td><code>ctor</code></td>\n        <td><code>Function</code></td>\n        <td>\n            A constructor function which will be mapped to the data being pulled from the server. <b>Note: async only</b>\n        </td>\n    </tr>\n    <tr>\n        <td><code>ajaxOptions</code></td>\n        <td><code>Object</code></td>\n        <td>\nAn options hash to be passed into the jQuery <code>$.ajax</code> method when a page is requested asynchronously. <b>Note: async only</b>\n        </td>\n    </tr>\n</table>\n<p>You can see it in action in this fiddle:</p>\n<iframe style=\"width:100%;height:320px;\" src=\"http://jsfiddle.net/lelandrichardson/r9f2r/embedded/result,js,html\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<br/>\nUnfortunately, the source had to be hacked a little bit in order to work with jsFiddle's JSON echo API, but it demonstrates the asynchronous nature of the pager that can be achieved.  If I get a bit further with this project, I will provide some more complete examples and update this article.\n<h2>Future Development</h2>\n<p>As this is a plugin that I believe I myself will use, I would like to keep improving on it.  I am open to suggestions on the best way to do that.  If you have opinions on how this API should change or be improved, please share! (or submit a pull request).</p>\n<p>I have the source available on <a href=\"https://github.com/lelandrichardson/knockout-paged\">GitHub: lelandrichardson/knockout-paged</a></p>\n<p>My major plans for it right now (other than fixing bugs and making it more robust) is to add support for RESTful endpoints.</p>\n<p>My thoughts is this could go something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Example = function(){\n    // instead of providing a url template, you would simply provide the resource name \n    // and it would do the rest of the work\n    this.apples = ko.observableArray().paged({\n        pageSize: 10,\n        resource: &#39;/apple&#39;\n    });\n};</code></pre></div>\n<p>RESTful API’s have an entirely different way of handling paged datasets, which is by sending back one or more “next”, “prev”, “first”, and “last” URLs along with the response.  I intend on adding handling of this by default soon, and I think this could result in a very clean API. I am certainly open to suggestions here as well.</p>",
      "fields": { "readingTime": { "text": "13 min read" } },
      "frontmatter": {
        "title": "Handling Paged Datasets in Knockout.js",
        "date": "April 23, 2013"
      }
    }
  },
  "pageContext": {
    "slug": "/handling-paged-datasets-in-knockoutjs/",
    "previous": {
      "fields": { "slug": "/hello-world/" },
      "frontmatter": { "title": "Lets look at some code" }
    },
    "next": {
      "fields": { "slug": "/text-headings/" },
      "frontmatter": { "title": "Just text and links" }
    }
  }
}
