<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/app.1b56f0f3ea8e10aaf677.css">@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:200;src:local("Oswald Extra Light "),local("Oswald-Extra Light"),url(/static/oswald-latin-200-7de4e8c7241042bac22064babb6649a6.woff2) format("woff2"),url(/static/oswald-latin-200-74b035507786c9fa80f85f11d92a502c.woff) format("woff")}@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:300;src:local("Oswald Light "),local("Oswald-Light"),url(/static/oswald-latin-300-dc15f3b07cb711e818ecb48de992992c.woff2) format("woff2"),url(/static/oswald-latin-300-d2c191b2e46f060bf90b34e6b3f73d83.woff) format("woff")}@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:400;src:local("Oswald Regular "),local("Oswald-Regular"),url(/static/oswald-latin-400-f15aa285863274b4f6ed578caa76565e.woff2) format("woff2"),url(/static/oswald-latin-400-ca70f49a133f08485bd05d5cb28ef8b7.woff) format("woff")}@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:500;src:local("Oswald Medium "),local("Oswald-Medium"),url(/static/oswald-latin-500-541a863959122f29c9961095cdcbb5c2.woff2) format("woff2"),url(/static/oswald-latin-500-deebf8fc5d31111f3144d0c6373143cc.woff) format("woff")}@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:600;src:local("Oswald SemiBold "),local("Oswald-SemiBold"),url(/static/oswald-latin-600-b81a3735849bb304ae25ae10c748d5ab.woff2) format("woff2"),url(/static/oswald-latin-600-452513e2767e99884b1c084dad03126b.woff) format("woff")}@font-face{font-family:Oswald;font-style:normal;font-display:swap;font-weight:700;src:local("Oswald Bold "),local("Oswald-Bold"),url(/static/oswald-latin-700-3e941c0d10bcb614ac1442884055d2bf.woff2) format("woff2"),url(/static/oswald-latin-700-7eb521f12cd966b030825fa662677353.woff) format("woff")}code[class*=language-],pre[class*=language-]{color:#ccc;background:none;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}</style><meta name="generator" content="Gatsby 2.0.76"/><style data-styled="kvIrRe jXNdrO hnIOCF fkIoOY kxKAiC yAlUC cSXGyp hDpBCN dBkJBP jSWxAb eYyouk fnCCfl jqdpqf ldSKzY hVzkRp iDGdFF fjerEM" data-styled-version="4.1.3">
/* sc-component-id: styled-link__StyledLink-mjb46b-0 */
.jXNdrO{-webkit-text-decoration:none;text-decoration:none;color:rgba(0,0,0,0.8);}
/* sc-component-id: header__Container-di30r3-0 */
.kvIrRe{box-shadow:0 4px 12px 0 rgba(0,0,0,0.05);height:6rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}
/* sc-component-id: header__Title-di30r3-1 */
.hnIOCF{font-size:1.6rem;font-weight:800;-webkit-letter-spacing:0.1rem;-moz-letter-spacing:0.1rem;-ms-letter-spacing:0.1rem;letter-spacing:0.1rem;text-transform:uppercase;margin:0 auto 0 24px;} @media (max-width:36em){.hnIOCF{text-align:center;}}
/* sc-component-id: header__Icon-di30r3-2 */
.fkIoOY{height:2.5rem;width:2.5rem;padding:1.5rem 1rem;margin-right:24px;}
/* sc-component-id: sc-global-332799677 */
@font-face{font-family:system;font-style:normal;font-weight:300;src:local('.SFNSText-Light'),local('.HelveticaNeueDeskInterface-Light'), local('.LucidaGrandeUI'),local('Ubuntu Light'),local('Segoe UI Light'), local('Roboto-Light'),local('DroidSans'),local('Tahoma');} :root{font-size:10px;} body{font-family:Verdana;margin:0;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;color:rgba(0,0,0,0.8);min-height:100vh;position:relative;font-size:1.9rem;} h1,h2,h3,h4,h5,h6{font-family:'Oswald',sans-serif;} h2{font-size:2.5rem;} h3{font-size:2.4rem;} h4{font-size:1.9rem;} code{font-family:Menlo,Monaco,"Courier New",Courier,monospace;word-break:break-word;} code[class*="language-"],pre[class*="language-"]{line-height:1.3;} pre code{word-break:normal;font-size:1.4rem;} :not(pre) > code[class*="language-"]{background-color:#eaeaea;padding:.1em 0.5em;border-radius:.2em;color:#8a4519;font-size:smaller;line-height:1.6;} .table{width:100%;border:1px solid #222;border-spacing:0;border-collapse:collapse;font-size:1.4rem;} .table td,.table th{padding:4px;vertical-align:top;border-top:1px solid #222;border:1px solid #222;} .table thead th{vertical-align:bottom;border-bottom:2px solid #222;} .remark-code-title{margin-bottom:-8px;padding:0.5em 1em;font-family:Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;background-color:#464646;color:white;z-index:0;border-top-left-radius:0.3em;border-top-right-radius:0.3em;} twitter-widget{margin:10px auto;}
/* sc-component-id: layout__Footer-sc-14pgzi3-0 */
.fjerEM{display:block;height:6rem;}
/* sc-component-id: layout__Content-sc-14pgzi3-1 */
.kxKAiC{width:60%;max-width:728px;margin:0 auto;} @media (max-width:48em){.kxKAiC{width:80%;}}
/* sc-component-id: post-styles__Container-axwg2q-0 */
.yAlUC{margin-top:8rem;} @media (max-width:36em){.yAlUC{margin-top:4rem;}} .yAlUC p{line-height:1.5;} .yAlUC blockquote{margin-left:0.25rem;font-size:1.6rem;color:inherit;font-style:italic;border-left:0.2rem solid rgb(0,0,0);padding-left:1rem;margin:1rem 0;} .yAlUC pre{margin-bottom:2rem;} .yAlUC h3{line-height:1.13;} .yAlUC h2,.yAlUC h3,.yAlUC h4,.yAlUC h5,.yAlUC h6{margin:2rem 0 2rem;} .yAlUC hr{border:0;border-top:0.1rem solid #ccc;display:block;height:1rem;padding:0;}
/* sc-component-id: post-styles__Header-axwg2q-1 */
@media (max-width:48em){.cSXGyp{text-align:center;}}
/* sc-component-id: post-styles__Title-axwg2q-2 */
.hDpBCN{margin-bottom:1rem;font-size:3rem;}
/* sc-component-id: post-styles__LinkList-axwg2q-3 */
.iDGdFF{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;list-style:none;padding:0px;}
/* sc-component-id: bio__Container-hbzvw6-0 */
.eYyouk{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:5rem 0;} @media (max-width:48em){.eYyouk{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;text-align:center;}}
/* sc-component-id: bio__TextContainer-hbzvw6-1 */
@media (max-width:36em){.fnCCfl{-webkit-order:2;-ms-flex-order:2;order:2;}}
/* sc-component-id: bio__ImageContainer-hbzvw6-2 */
@media (max-width:36em){.hVzkRp{-webkit-order:1;-ms-flex-order:1;order:1;}}
/* sc-component-id: bio__Name-hbzvw6-3 */
.jqdpqf{font-size:2.4rem;-webkit-letter-spacing:0.1rem;-moz-letter-spacing:0.1rem;-ms-letter-spacing:0.1rem;letter-spacing:0.1rem;font-weight:800;margin-bottom:1rem;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;font-family:"system";}
/* sc-component-id: bio__TagLine-hbzvw6-4 */
.ldSKzY{font-weight:normal;font-size:1.6rem;margin:0;margin-right:3rem;display:block;}
/* sc-component-id: sc-bdVaJa */
.dBkJBP{color:rgba(0,0,0,0.8);}
/* sc-component-id: sc-bwzfXH */
.jSWxAb{margin:5rem 0;}</style><title data-react-helmet="true">Compose From First Principles | Intelligible Babble</title><link data-react-helmet="true" rel="alternate" type="application/rss+xml" href="/rss.xml"/><meta data-react-helmet="true" name="description" content="Last week was the week of Google I/O 2019. It was a particularly exciting I/O for me, as it was the first time Google has talked publicly…"/><meta data-react-helmet="true" property="og:title" content="Compose From First Principles"/><meta data-react-helmet="true" property="og:description" content="Last week was the week of Google I/O 2019. It was a particularly exciting I/O for me, as it was the first time Google has talked publicly…"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="Leland Richardson"/><meta data-react-helmet="true" name="twitter:title" content="Compose From First Principles"/><meta data-react-helmet="true" name="twitter:description" content="Last week was the week of Google I/O 2019. It was a particularly exciting I/O for me, as it was the first time Google has talked publicly…"/><link rel="alternate" type="application/rss+xml" title="Leland Richardson&#x27;s Personal Blog" href="/rss.xml"/><link rel="shortcut icon" href="/icons/icon-48x48.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link as="script" rel="preload" href="/0-f4a92f803a58fa4f13be.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-de3c6a0173b5a6249af2.js"/><link as="script" rel="preload" href="/1-60be38d63a7fd6e426ec.js"/><link as="script" rel="preload" href="/app-de31d325c9748b7c69de.js"/><link as="script" rel="preload" href="/webpack-runtime-7e8dde12bbe8249ecfa7.js"/><link as="fetch" rel="preload" href="/static/d/120/path---compose-from-first-principles-4-a-3-b89-60eUWdZcGprbfbfQC7rgKexDxLg.json" crossOrigin="use-credentials"/></head><body><noscript>Sorry! This site requires JavaScript to be enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><nav class="header__Container-di30r3-0 kvIrRe"><a class="styled-link__StyledLink-mjb46b-0 jXNdrO" href="/"><h1 class="header__Title-di30r3-1 hnIOCF">Intelligible Babble</h1></a><a style="margin-left:auto" href="https://twitter.com/intelligibabble" target="_blank" rel="noopener noreferrer"><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pg0KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE4LjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgNjEyIDYxMiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjEyIDYxMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPGc+DQoJPGc+DQoJCTxwYXRoIHN0eWxlPSJmaWxsOiMwMTAwMDI7IiBkPSJNNjEyLDExNi4yNThjLTIyLjUyNSw5Ljk4MS00Ni42OTQsMTYuNzUtNzIuMDg4LDE5Ljc3MmMyNS45MjktMTUuNTI3LDQ1Ljc3Ny00MC4xNTUsNTUuMTg0LTY5LjQxMQ0KCQkJYy0yNC4zMjIsMTQuMzc5LTUxLjE2OSwyNC44Mi03OS43NzUsMzAuNDhjLTIyLjkwNy0yNC40MzctNTUuNDktMzkuNjU4LTkxLjYzLTM5LjY1OGMtNjkuMzM0LDAtMTI1LjU1MSw1Ni4yMTctMTI1LjU1MSwxMjUuNTEzDQoJCQljMCw5LjgyOCwxLjEwOSwxOS40MjcsMy4yNTEsMjguNjA2QzE5Ny4wNjUsMjA2LjMyLDEwNC41NTYsMTU2LjMzNyw0Mi42NDEsODAuMzg2Yy0xMC44MjMsMTguNTEtMTYuOTgsNDAuMDc4LTE2Ljk4LDYzLjEwMQ0KCQkJYzAsNDMuNTU5LDIyLjE4MSw4MS45OTMsNTUuODM1LDEwNC40NzljLTIwLjU3NS0wLjY4OC0zOS45MjYtNi4zNDgtNTYuODY3LTE1Ljc1NnYxLjU2OGMwLDYwLjgwNiw0My4yOTEsMTExLjU1NCwxMDAuNjkzLDEyMy4xMDQNCgkJCWMtMTAuNTE3LDIuODMtMjEuNjA3LDQuMzk4LTMzLjA4LDQuMzk4Yy04LjEwNywwLTE1Ljk0Ny0wLjgwMy0yMy42MzQtMi4zMzNjMTUuOTg1LDQ5LjkwNyw2Mi4zMzYsODYuMTk5LDExNy4yNTMsODcuMTk0DQoJCQljLTQyLjk0NywzMy42NTQtOTcuMDk5LDUzLjY1NS0xNTUuOTE2LDUzLjY1NWMtMTAuMTM0LDAtMjAuMTE2LTAuNjEyLTI5Ljk0NC0xLjcyMWM1NS41NjcsMzUuNjgxLDEyMS41MzYsNTYuNDg1LDE5Mi40MzgsNTYuNDg1DQoJCQljMjMwLjk0OCwwLDM1Ny4xODgtMTkxLjI5MSwzNTcuMTg4LTM1Ny4xODhsLTAuNDIxLTE2LjI1M0M1NzMuODcyLDE2My41MjYsNTk1LjIxMSwxNDEuNDIyLDYxMiwxMTYuMjU4eiIvPg0KCTwvZz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjwvc3ZnPg0K" alt="twitter" class="header__Icon-di30r3-2 fkIoOY"/></a><a href="https://github.com/lelandrichardson" target="_blank" rel="noopener noreferrer"><img src="data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+R2l0SHViIGljb248L3RpdGxlPjxwYXRoIGQ9Ik0xMiAuMjk3Yy02LjYzIDAtMTIgNS4zNzMtMTIgMTIgMCA1LjMwMyAzLjQzOCA5LjggOC4yMDUgMTEuMzg1LjYuMTEzLjgyLS4yNTguODItLjU3NyAwLS4yODUtLjAxLTEuMDQtLjAxNS0yLjA0LTMuMzM4LjcyNC00LjA0Mi0xLjYxLTQuMDQyLTEuNjFDNC40MjIgMTguMDcgMy42MzMgMTcuNyAzLjYzMyAxNy43Yy0xLjA4Ny0uNzQ0LjA4NC0uNzI5LjA4NC0uNzI5IDEuMjA1LjA4NCAxLjgzOCAxLjIzNiAxLjgzOCAxLjIzNiAxLjA3IDEuODM1IDIuODA5IDEuMzA1IDMuNDk1Ljk5OC4xMDgtLjc3Ni40MTctMS4zMDUuNzYtMS42MDUtMi42NjUtLjMtNS40NjYtMS4zMzItNS40NjYtNS45MyAwLTEuMzEuNDY1LTIuMzggMS4yMzUtMy4yMi0uMTM1LS4zMDMtLjU0LTEuNTIzLjEwNS0zLjE3NiAwIDAgMS4wMDUtLjMyMiAzLjMgMS4yMy45Ni0uMjY3IDEuOTgtLjM5OSAzLS40MDUgMS4wMi4wMDYgMi4wNC4xMzggMyAuNDA1IDIuMjgtMS41NTIgMy4yODUtMS4yMyAzLjI4NS0xLjIzLjY0NSAxLjY1My4yNCAyLjg3My4xMiAzLjE3Ni43NjUuODQgMS4yMyAxLjkxIDEuMjMgMy4yMiAwIDQuNjEtMi44MDUgNS42MjUtNS40NzUgNS45Mi40Mi4zNi44MSAxLjA5Ni44MSAyLjIyIDAgMS42MDYtLjAxNSAyLjg5Ni0uMDE1IDMuMjg2IDAgLjMxNS4yMS42OS44MjUuNTdDMjAuNTY1IDIyLjA5MiAyNCAxNy41OTIgMjQgMTIuMjk3YzAtNi42MjctNS4zNzMtMTItMTItMTIiLz48L3N2Zz4=" alt="github" class="header__Icon-di30r3-2 fkIoOY"/></a><a href="/rss.xml" rel="alternate" type="application/rss+xml"><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDU2LjY5MyA1Ni42OTMiIGhlaWdodD0iNTYuNjkzcHgiIGlkPSJMYXllcl8xIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA1Ni42OTMgNTYuNjkzIiB3aWR0aD0iNTYuNjkzcHgiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxwYXRoIGQ9Ik0zLjQyOCwzMS4wODVjNi4xOSwwLDEyLjAwOSwyLjQxOCwxNi4zODIsNi44MTZjNC4zODEsNC4zOTgsNi43OTMsMTAuMjU2LDYuNzkzLDE2LjQ5Mmg5LjUzOSAgYzAtMTguMTEzLTE0LjY3Ni0zMi44NDgtMzIuNzE0LTMyLjg0OFYzMS4wODV6IE0zLjQ0MywxNC4xNzRjMjIuMDYxLDAsNDAuMDEsMTguMDQ3LDQwLjAxLDQwLjIzMWg5LjUzOSAgYzAtMjcuNDQ1LTIyLjIyOS00OS43Ny00OS41NDktNDkuNzdWMTQuMTc0eiBNMTYuNjM0LDQ3Ljc0MWMwLDMuNjQ4LTIuOTU5LDYuNjA3LTYuNjA3LDYuNjA3UzMuNDIsNTEuMzksMy40Miw0Ny43NDEgIGMwLTMuNjUsMi45NTgtNi42MDcsNi42MDYtNi42MDdTMTYuNjM0LDQ0LjA5MSwxNi42MzQsNDcuNzQxeiIvPjwvc3ZnPg==" alt="Rss Feed" class="header__Icon-di30r3-2 fkIoOY"/></a></nav><div class="layout__Content-sc-14pgzi3-1 kxKAiC"><article class="post-styles__Container-axwg2q-0 yAlUC"><header class="post-styles__Header-axwg2q-1 cSXGyp"><h1 class="post-styles__Title-axwg2q-2 hDpBCN">Compose From First Principles</h1><sub class="sc-bdVaJa dBkJBP"><span>Posted on <!-- -->May 13, 2019</span><span>  -  </span><span>22 min read</span></sub></header><div class="sc-bwzfXH jSWxAb"><p>Last week was the week of Google I/O 2019. It was a particularly exciting I/O for me, as it was the first time Google has talked publicly about Jetpack Compose, the project I was hired to work on in February of 2018.</p>
<p>Compose is an ambitious multi-team effort to reimagine Android’s UI Toolkit more than 10 years after the Android Platform launched with the original UI Toolkit.</p>
<p>If you haven’t yet watched the <a href="https://www.youtube.com/watch?v=VsStyq4Lzxo">session on Declarative UI Patterns</a>, you should do that now. It is a proper overview of the motivations and goals behind the project, which this post is <em>not</em>.</p>
<iframe 
  style="width:100%;height:320px;" 
  src="https://www.youtube.com/embed/VsStyq4Lzxo" 
  frameborder="0" 
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" 
  allowfullscreen
></iframe>
<p>Since we’ve announced and <a href="http://d.android.com/jetpackcompose">open sourced Compose</a>, it has generated a lot of interest and questions about how it works. I spent some time thinking about what the right thing to talk about first would be. There’s so much to talk about and a lot of pieces that work together and are hard to understand without the context of the other pieces.</p>
<p>Ultimately, I came to the conclusion of writing this post. There will (hopefully!) be many more blog posts that follow this one that go into depth about more specific topics, but I think it’s important to start with a good foundational overview.</p>
<p>The goal of this post is to give people a solid mental model around what Compose <em>does</em>, and eliminate anything one might think of as “magic”. One of the best ways to do this, I think, is to try and construct a simpler version of what we’re doing, and incrementally add on to it until we have something that resembles the real thing. In other words, let’s try and build Compose starting from nothing but “first principles”.</p>
<p>It’s important to say outright that the <strong>details of this post may not be 100% technically accurate</strong>. Even if they were, Compose is so early in its development that it would quickly <em>become</em> inaccurate. Nevertheless, I will do my best to point out places where I’m simplifying things or talking about aspects that are still unimplemented.</p>
<p>todo: indicate that the goal of this blog is not to convince someone of the motivations behind the programming paradigm or the change, but instead to help describe how ir works.</p>
<h2>Underlying Mental Model</h2>
<p>At its core, Compose is designed to efficiently build <em>and maintain</em> tree-like data structures. More specifically, it provides a programming model to describe how that tree will <em>change over time</em>.</p>
<p>This programming model is not entirely new. We’ve gotten a lot of inspiration from other frameworks such as Flutter, React, Litho, Vue, and more, all of which mostly accomplish the same goal, albeit in slightly different ways. (todo: link each one)</p>
<p>As one might surmise from the list of frameworks above, one of the more compelling use cases for this type of a system is to build user interfaces (UIs). UIs are typically tree-like data structures that change over time. Moreover, UIs are becoming more and more dynamic and complicated, resulting in demand for a programming model to help tame that complexity.</p>
<p>For Compose, the actual type of the tree does not matter much here. Compose’s runtime does not target a specific tree node type, but rather requires that you implement an <code class="language-text">ApplyAdapter&lt;N&gt;</code> interface for any type of tree node base class <code class="language-text">N</code>.</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> ApplyAdapter<span class="token operator">&lt;</span>N<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> N<span class="token punctuation">.</span><span class="token function">insertAt</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">,</span> instance<span class="token operator">:</span> N<span class="token punctuation">)</span>
    <span class="token keyword">fun</span> N<span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">,</span> count<span class="token operator">:</span> Int<span class="token punctuation">)</span>
    <span class="token keyword">fun</span> N<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span>from<span class="token operator">:</span> Int<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token operator">:</span> Int<span class="token punctuation">,</span> count<span class="token operator">:</span> Int<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>These three operations are really all that we need to manage a tree. Compose is already being used to target several different tree types: Android Views, ComponentNodes, Vectors, TextSpan, and there will likely be more to come.</p>
<p>Rather than go into details about how this generalism is achieved, lets define a basic tree-like data structure that we can use for the purposes of this blog post.</p>
<p>We can imagine an extremely simple UI library that had the following types defined:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">abstract</span> <span class="token keyword">class</span> Node <span class="token punctuation">{</span>
   <span class="token keyword">val</span> children <span class="token operator">=</span> mutableListOf<span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">class</span> Box <span class="token operator">:</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
<span class="token keyword">class</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token keyword">var</span> text<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>
<p>Here we just have two primitives: <code class="language-text">Box</code> and <code class="language-text">Text</code>. In reality there would probably be more, and they would probably have more properties, but again, we are keeping it simple. In the existing Android toolkit, this would correspond to <a href="https://developer.android.com/reference/android/view/View"><code class="language-text">View</code></a> and all of it’s subclasses, and on the web this would correspond to any <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element"><code class="language-text">Element</code></a>.</p>
<p>Now we need a way to take a tree of Nodes, and render their current state to the screen:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span></code></pre></div>
<p>A “Hello World” type application in this application might look something like this:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> onVsync <span class="token punctuation">{</span>
  <span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Of course we have glossed over a lot of complexity that might go into the <code class="language-text">renderNodeToScreen</code> method, but let’s just assume that it works and works well. For the purposes of this article, it’s implementation is not important.</p>
<p>Let’s move on to a slightly more complex example of a “To Do List” App.</p>
<h2>UI as a Transform Function</h2>
<p>A practical guiding principle to structuring an application is to separate the concept of a “model” from that of the “UI”.  </p>
<p>Given our “model” as a set of <code class="language-text">TodoItem</code>s, one way to do this is to create a function that just transforms our list of items into a tree of <code class="language-text">Node</code>s:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Node <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           children<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span> <span class="token punctuation">{</span>
               children<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>
                   <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
               <span class="token punctuation">)</span>
           <span class="token punctuation">}</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>This can be used elsewhere in your app to render the UI to the screen in response to your application-specific data model. We can imagine a working app as something like:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  todoItemRepository<span class="token punctuation">.</span><span class="token function">observe</span> <span class="token punctuation">{</span> items <span class="token operator">-></span>
    <span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>There are a few problems with this approach:</p>
<p>todo: refine these problems</p>
<ol>
<li><strong>Composability</strong>. It is difficult to break the logic of transforming data into this tree into smaller pieces.</li>
<li><strong>Allocations</strong> UIs can often have very large trees, but only small parts of them change dynamically</li>
<li><strong>Allocations</strong> Every time we want to update something, we end up recreating (reallocating) the entire tree</li>
</ol>
<p>To address some of these issues, lets create an abstraction for “emitting” nodes into a context object, instead of explicitly adding nodes to the children array of the parent.</p>
<p>This context object is helping us “compose” the tree, so let’s call it a <code class="language-text">Composer</code>. The simplest implementation of this could be the following:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Composer <span class="token punctuation">{</span>
  <span class="token comment">// add node as a child to the current Node, execute </span>
  <span class="token comment">// `block` with `node` as the current Node</span>
  <span class="token keyword">fun</span> <span class="token function">emit</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">,</span> block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token function">ComposerImpl</span><span class="token punctuation">(</span>root<span class="token operator">:</span> Node<span class="token punctuation">)</span><span class="token operator">:</span> Composer <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> current<span class="token operator">:</span> Node <span class="token operator">=</span> root

  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">emit</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">,</span> block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> parent <span class="token operator">=</span> current
    parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    current <span class="token operator">=</span> node
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    current <span class="token operator">=</span> parent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Now we can imagine having a function called <code class="language-text">compose</code> with the following shape:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">compose</span><span class="token punctuation">(</span>block<span class="token operator">:</span> Composer<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> Node <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> <span class="token function">ComposerImpl</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Using this new abstraction, we can rewrite our To Do App above:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Now, whenever we want to render our UI based on the items we have, we can run the following:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">// render UI</span>
<span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span>compose <span class="token punctuation">{</span> <span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div>
<p>With this new abstraction, it is also easy to pull out parts of our UI into smaller functions:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token operator">:</span> TodoItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>todo: Problems:</p>
<ul>
<li>no way to create local state</li>
<li>allocations, performance</li>
</ul>
<h2>Positional Memoization</h2>
<p>Someone performance conscious might look at the previous example we had and realize that we are creating a completely new tree every time we run <code class="language-text">compose</code>. For large applications, this could create a lot of garbage on each successive pass. Furthermore, it means that if any of those nodes have any private state, the state will get thrown away.</p>
<p>There are several ways one might go about fixing this, but Compose utilizes a technique we are calling “Positional Memoization”. Much of Compose’s architecture is built around this technique, so let’s try to build up a solid mental model of how it works.</p>
<p>In the last section, we introduced a <code class="language-text">Composer</code> object, which held some of the context of where in the tree we were and what node we were emitting into currently. Our goal is to preserve the programming model we had above, but try and reuse the nodes that we had created in the previous execution of the UI. Essentially, we want to cache each node.</p>
<p>Most caches require keys; some way of identifying which object you’re wanting to retrieve the cached result of. Assuming we are caching each node in the tree we are creating, in the example above we can see that every time we execute the <code class="language-text">TodoApp</code> function, we will consult the cache in the same exect order every time the function is executed (this logic breaks down if we introduce any conditional logic into our app, but we’ll get to that later).</p>
<p>If we utilize <em>execution order</em> as the cache key, we can avoid lookups entirely; we can just use a flat list or array to hold the nodes, which should mean that retrieval is very cheap. We can just keep track of a “current index” while we execute the app transform function and increment it every time we retrieve a value.</p>
<p>As a simple implementation of this, consider the following two methods being added to the <code class="language-text">Composer</code> class we had above:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Composer <span class="token punctuation">{</span>
  <span class="token comment">// returns whether current cached item matches the passed in value. </span>
  <span class="token comment">// If it doesn't, it replaces it in the table. consumes item.</span>
  <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">changed</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean

  <span class="token comment">// return the current item in the cache, if `update` is true or the </span>
  <span class="token comment">// cache is empty, run `factory`, cache and return result</span>
  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">cache</span><span class="token punctuation">(</span>update<span class="token operator">:</span> Boolean<span class="token punctuation">,</span> factory<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">:</span> T
<span class="token punctuation">}</span>

<span class="token keyword">class</span> ComposerImpl<span class="token operator">:</span> Composer <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> cache <span class="token operator">=</span> mutableListOf<span class="token operator">&lt;</span>Any<span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">private</span> <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span>
 
  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">changed</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>
    <span class="token keyword">val</span> index <span class="token operator">=</span> index<span class="token operator">++</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span>size <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cache<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value
        <span class="token boolean">false</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> item <span class="token operator">=</span> cache<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
        cache<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> value
        item <span class="token operator">!=</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">cache</span><span class="token punctuation">(</span>update<span class="token operator">:</span> Boolean<span class="token punctuation">,</span> factory<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">)</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> cache<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> it <span class="token punctuation">}</span>
    <span class="token keyword">else</span> cache<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token keyword">as</span> T
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>With these primitives one can create a more general purpose <code class="language-text">memo</code> function:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">// Compoare each input with the previous value at this position. If any </span>
<span class="token comment">// have changed, return result of factory, otherwise return previous result</span>
<span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Composer<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">vararg</span> inputs<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> factory<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span>
   <span class="token keyword">var</span> valid <span class="token operator">=</span> <span class="token boolean">true</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>input <span class="token keyword">in</span> inputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       valid <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">changed</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> valid
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token function">cache</span><span class="token punctuation">(</span><span class="token operator">!</span>valid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Note that <code class="language-text">memo</code> will increment the cache index <code class="language-text">n+1</code> times when it is called with <code class="language-text">n</code> inputs. This means that it has the expectation that it will be called with the same number of inputs each time it is called for a given “position”, or else the cache could get misaligned over time.</p>
<p>With this <code class="language-text">memo</code> function, we are able to change our previous <code class="language-text">TodoApp</code> example to now take advantage of memoization:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token operator">:</span> TodoItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span>
       <span class="token function">memo</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>completed<span class="token punctuation">,</span> item<span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span>memo <span class="token punctuation">{</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Now, every time we run <code class="language-text">compose</code>, the nodes in the tree are reused unless they change. However, since we are using execution order to memoize, the amount of memory that we are using remains unchanged, and our programming model remains unchanged as well.</p>
<p>In the current example, an entire node is either memoized or not, but we can actually start to memoize individual properties of a node, provided they are mutable.</p>
<p>For instance, consider the fact that <code class="language-text">text</code> is a mutable property of <code class="language-text">Text</code>:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token keyword">var</span> text<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>
<p>Because of this, we can memoize all Text nodes, and just update the <code class="language-text">text</code> attribute when it changes. To do this, we want a slightly different signature of <code class="language-text">emit</code>:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Composer <span class="token punctuation">{</span>
   <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">:</span> Node<span class="token operator">></span> <span class="token function">emit</span><span class="token punctuation">(</span>
           factory<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> T<span class="token punctuation">,</span>
           update<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
           block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>In this version of <code class="language-text">emit</code>, we pass a <code class="language-text">factory</code> function, which <code class="language-text">emit</code> memoizes to create the <code class="language-text">Node</code> itself. Then, the <code class="language-text">update</code> function is called with the current <code class="language-text">Node</code> instance. Inside of <code class="language-text">update</code>, we can memoize the setting of the properties of it individually.</p>
<p>For instance, the <code class="language-text">TodoItem</code> component can be rewritten as:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token operator">:</span> TodoItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">val</span> text <span class="token operator">=</span> <span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span>
   <span class="token function">emit</span><span class="token punctuation">(</span>
       <span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> text <span class="token punctuation">}</span><span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>So to enable optimum reuse, we can memoize each property individually, and reuse <code class="language-text">Node</code> instances across every <code class="language-text">compose</code> call.</p>
<p>The keen reader might look at this and notice that there is a problem with this memoization approach. This seems to break down when we introduce any type of control flow into our transform functions. For example, consider the following <code class="language-text">TodoApp</code> function:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">val</span> text <span class="token operator">=</span> <span class="token string">"Total: <span class="token interpolation"><span class="token delimiter variable">${</span>items<span class="token punctuation">.</span>size<span class="token delimiter variable">}</span></span> items"</span>
  <span class="token function">emit</span><span class="token punctuation">(</span>
       <span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> text <span class="token punctuation">}</span><span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>In this example, if we had 2 items the first time the app composed, and 3 items the second time, what would happen?</p>
<p>The first two items would memoize correctly, but when we encounter the third item, we would start to “memoize” using the <code class="language-text">Text</code> node that was previously used below the list of TodoItems in the first pass! Essentially, any time there is any control-flow that causes the number of items cached in the list to change, everything after that conditional logic would be misaligned with the cache.</p>
<p>To fix this, we need to introduce another fundamental concept to “Positional Memoization”: Groups.</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Composer <span class="token punctuation">{</span>
   <span class="token comment">// start a group, execute block inside that group, end the group</span>
   <span class="token keyword">fun</span> <span class="token function">group</span><span class="token punctuation">(</span>key<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>I’m going to leave the implementation of this out of this blog post. In reality, implementing this correctly is <a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/compose/runtime/src/main/java/androidx/compose/Composer.kt#592">quite complicated</a> and I think would distract from the post.</p>
<p>This concept complicates the implementation of the memoization cache of the composer, but it is critical for Positional Memoization to work correctly. Essentially, a group is what turns the linear cache into a tree-like structure, where we can then identify when nodes in that tree have been moved, removed, or added.</p>
<p>The <code class="language-text">group</code> method is expected to have a key passed into it. This key will be cached in the cache array just like inputs to <code class="language-text">memo</code>, but when it doesn’t match the key from the previous execution, the runtime will seek through the cache to determine if the group has been moved, removed, or is a new group to be inserted.</p>
<p>Note that the key itself of the group is only scoped to the immediate parent group, so there is no need for keys to be globally unique. Now if we want to correctly use groups in our TodoApp example, we might have something like:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token operator">:</span> TodoItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">val</span> text <span class="token operator">=</span> <span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span>
  <span class="token function">group</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span>
      <span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> text <span class="token punctuation">}</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token function">group</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 
   <span class="token keyword">val</span> text <span class="token operator">=</span> <span class="token string">"Total: <span class="token interpolation"><span class="token delimiter variable">${</span>items<span class="token punctuation">.</span>size<span class="token delimiter variable">}</span></span> items"</span>
   <span class="token function">group</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">emit</span><span class="token punctuation">(</span>
           <span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> text <span class="token punctuation">}</span> <span class="token punctuation">}</span>
       <span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>In this case, we’ve just assigned unique integers as the keys to each group. Importantly, we’ve also surrounded the call to <code class="language-text">TodoItem</code> with a group here, which will ensure that each TodoItem is memoized independently.</p>
<p>Now, when the size of <code class="language-text">items</code> changes from 2 to 3, we know to “add” items into the cache instead of look at the part of the cache that is ahead, since that would be outside of the group we are in. The same goes for cases where items are removed from the cache.</p>
<p>Items that “move” are similarly handled, although the algorithm to do so is a bit more complex. We won’t be getting into this in detail, but the important bit to understand is that we track “moves” in a group based on the key of the child group.  If we shuffled the <code class="language-text">items</code> list in this example, the fact that each TodoItem call is surrounded by a group with key <code class="language-text">1</code> means that the Composer has no way of knowing that the order of the items changed. This isn’t fatal, it just means that the number of changes that are memoized is unlikely to be minimal, and any state that was associated with the item may now be associated with a different item. We could, however, use the <code class="language-text">item</code> itself as the key:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">group</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Now, each group and the contained set of cached values in that group will move along with the items, and then <code class="language-text">TodoItem</code> will get called with the memoization cache of the same group from the previous compose, increasing the likelihood that the changes are minimal, with the cost of moving the cached items around.</p>
<p>I will talk more in a future post about these types of keys can manifest themselves automatically with the <code class="language-text">@Pivotal</code> attribute.</p>
<h1>State</h1>
<p>The examples so far have shown a UI that can be represented as a simple projection of data. The reality is that most UIs end up containing a number of stateful elements that don’t make any sense as part of the overall data model, but instead are specific to the UI itself (ie, “view state”).</p>
<p>Compose’s state model might be best understood if we try and build it up from the concepts we’ve discussed so far with Positional Memoization.</p>
<p>To discuss state, let’s change our app example to a simple counter UI with a “count”, an “Increment” button, and a “Reset” button. To start out, we can imagine implementing this just using a global state object:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span>
 
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">App</span><span class="token punctuation">(</span>recompose<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"<span class="token interpolation variable">$count</span>"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Increment"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Reset"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> recompose<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   recompose <span class="token operator">=</span> <span class="token punctuation">{</span>
       <span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span>compose <span class="token punctuation">{</span> <span class="token operator">&lt;</span>App recompose <span class="token operator">/</span><span class="token operator">></span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Here we can see that the App component is using global state, which means that if this component is used in multiple places, the state will be shared across each usage. Though this can be useful in some situations, it’s usually not what we want. We want to be able to create an “instance” of count that can be used locally to the “instance” of App across compositions. </p>
<p>How can we do this in Compose?</p>
<p>The most basic thing to try is to move count into App as a local variable:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">// NOTE: This example does NOT work</span>
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">App</span><span class="token punctuation">(</span>recompose<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span>
 
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"<span class="token interpolation variable">$count</span>"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Increment"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Reset"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>This doesn’t work because the variable <code class="language-text">count</code> will get re-initialized to zero every time the function gets invoked.</p>
<p>Note that this is remarkably similar to how the nodes used to get recreated every time the function was called, but we utilized positional memoization to fix that. It turns out that here we can do the exact same thing for local state!</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> State<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">var</span> value<span class="token operator">:</span> T<span class="token punctuation">)</span>
 
<span class="token keyword">fun</span> Composer<span class="token punctuation">.</span><span class="token function">App</span><span class="token punctuation">(</span>recompose<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">val</span> count <span class="token operator">=</span> memo <span class="token punctuation">{</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
 
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function">memo</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>count<span class="token punctuation">.</span>value<span class="token delimiter variable">}</span></span>"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Increment"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">"Reset"</span><span class="token punctuation">;</span> it<span class="token punctuation">.</span>onClick <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Now that we are using <code class="language-text">memo</code>, the instance of <code class="language-text">State</code> will be the same for every subsequent call of the function (but unique to its position in the UI tree). We can then mutate it and trigger a recomposition for the hierarchy so that the screen reflects the new value of the <code class="language-text">State</code> instance.</p>
<h1>The <code class="language-text">@Composable</code> Annotation</h1>
<p>OK, so we’ve gotten pretty far in being able to build our App’s UI using these <code class="language-text">Composer</code> extension functions. That said, we’ve managed to really complicate the basic operations though in an effort to make this approach efficient and robust.</p>
<hr>
<p>The above example suffers from the same problems that the memoizations of emits did before we introduced <code class="language-text">group</code> calls around them. If we want to create state inside of control-flow logic, which we do, then we will need to do the same thing here. </p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> count <span class="token operator">=</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> memo <span class="token punctuation">{</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></div>
<p>This feels a bit tiresome to need to do this every time we want to introduce state, and it is also easy to forget and end up with incorrect code, so we have created a way of doing this that is less error-prone, that we call Effects.</p>
<p>Effects are like bound composable function calls that are waiting to be “positionally called”, and the way you call them is with the <code class="language-text">+</code> operator:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> State<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">var</span> value<span class="token operator">:</span> T<span class="token punctuation">)</span>
 
<span class="token annotation builtin">@Composable</span> <span class="token keyword">fun</span> <span class="token function">App</span><span class="token punctuation">(</span>recompose<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">val</span> count <span class="token operator">=</span> <span class="token operator">+</span>memo <span class="token punctuation">{</span> <span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
 
   <span class="token operator">&lt;</span>Text text<span class="token operator">=</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">${</span>count<span class="token punctuation">.</span>value<span class="token delimiter variable">}</span></span>"</span> <span class="token operator">/</span><span class="token operator">></span>
   <span class="token operator">&lt;</span>Button text<span class="token operator">=</span><span class="token string">"Increment"</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span> count<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
   <span class="token operator">&lt;</span>Button<span class="token punctuation">;</span> text<span class="token operator">=</span><span class="token string">"Reset"</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span> count<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">recompose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre></div>
<p>The <code class="language-text">+</code> operator, similar to the KTX element syntax, takes care of wrapping the call with a group and a key that is unique to the location of the call in source.</p>
<p>As we will see later, Effects can be combined with observable @Model objects to make state really easy to work with in Compose, and remove some syntactic overhead, as well as ensure that a <code class="language-text">recompose</code> function isn’t needed. Thus, our example just becomes:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span> <span class="token keyword">fun</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> count <span class="token keyword">by</span> <span class="token operator">+</span>state <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span>
 
   <span class="token operator">&lt;</span>Text text<span class="token operator">=</span><span class="token string">"<span class="token interpolation variable">$count</span>"</span> <span class="token operator">/</span><span class="token operator">></span>
   <span class="token operator">&lt;</span>Button text<span class="token operator">=</span><span class="token string">"Increment"</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span> count<span class="token operator">++</span> <span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
   <span class="token operator">&lt;</span>Button text<span class="token operator">=</span><span class="token string">"Reset"</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span> count <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre></div>
<hr>
<p>This forms a solid mental model from which we can build on top of to understand Compose in greater detail.  The example above can be mapped to Compose directly, although it does not address problems (2) and (3) above, which Compose does and is explained in more detail further into this document.</p>
<p>To transition into the syntax of Compose, let’s perform the following transformations in our head:</p>
<p>The <code class="language-text">Composer</code> receiver parameter we defined in the functions above is actually an implicit context object that the Compose compiler passes around for you. The type of this object is inferred with the <code class="language-text">@Composable</code> annotation
The calls to other @Composable functions are done with a special syntax
The calls to <code class="language-text">emit</code> on the <code class="language-text">Composer</code> object are also done with the same special syntax</p>
<p>Using these mappings, the example above can be rewritten to be:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span> <span class="token keyword">fun</span> <span class="token function">TodoItem</span><span class="token punctuation">(</span>item<span class="token operator">:</span> TodoItem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span>Text text<span class="token operator">=</span><span class="token string">"[${if (item.completed) "</span>x<span class="token string">" else "</span> <span class="token string">"}] <span class="token interpolation"><span class="token delimiter variable">${</span>item<span class="token punctuation">.</span>title<span class="token delimiter variable">}</span></span>"</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span>
 
<span class="token annotation builtin">@Composable</span> <span class="token keyword">fun</span> <span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span>Box<span class="token operator">></span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token operator">&lt;</span>TodoItem item <span class="token operator">/</span><span class="token operator">></span>
       <span class="token punctuation">}</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>Box<span class="token operator">></span>
<span class="token punctuation">}</span>
 
<span class="token comment">// render UI</span>
<span class="token function">renderNodeToScreen</span><span class="token punctuation">(</span>compose <span class="token punctuation">{</span> <span class="token operator">&lt;</span>TodoApp items <span class="token operator">/</span><span class="token operator">></span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div>
<p>As we can see from this example, there is an intentional duality between “emitting” a Node with certain attributes into the Composer and “calling” a function with some parameters which may then “emit” something into the Composer.</p>
<p>We will use this mental model as a basis for understanding Compose. Compose introduces a concept called “Positional Memoization” which is a solution to the problems (2) and (3) posed above. We will talk about it in more detail below, but we will first delve into a few more concepts in the meantime.</p>
<p>This forms a good solution to (1) above, but (2) and (3) are not yet solved. These problems are solved with Compose with Positional Memoization, but is not readily addressed with this simplistic model.</p>
<p>We are going to discuss a few other concepts before jumping into Positional Memoization though.</p>
<hr>
<p>As we can see here, there is quite a bit of ceremony around introducing new groups and keys manually for every single emit and call. Continuing the theme, the KTX element syntax also encompasses the creation of a group with a key. The key chosen is actually an integer that is computed from the unique position of the element in the source code. This is why we call it “Positional Memoization”: the memoization cache is keyed on the position of the element in source code, as well as the call graph. This means that, practically speaking, every element in the source code will have its own unique key that is part of its compilation. By using this position hash, we are able to leverage execution order for memoization while also allowing for conditional logic. </p>
<p>With these groups incorporated into the syntax of a KTX element, we see that our example simplifies down into this:</p>
<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Composable</span> <span class="token keyword">fun</span> <span class="token function">TodoApp</span><span class="token punctuation">(</span>items<span class="token operator">:</span> List<span class="token operator">&lt;</span>TodoItem<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">&lt;</span>Box<span class="token operator">></span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token operator">&lt;</span>TodoItem item <span class="token operator">/</span><span class="token operator">></span>
       <span class="token punctuation">}</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>Box<span class="token operator">></span>
   <span class="token operator">&lt;</span>Text text<span class="token operator">=</span><span class="token string">"Total: <span class="token interpolation"><span class="token delimiter variable">${</span>items<span class="token punctuation">.</span>size<span class="token delimiter variable">}</span></span> items"</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token punctuation">}</span></code></pre></div>
<p>todo: things this blog post doesn’t talk about…</p>
<ul>
<li>deferral/parallelization</li>
<li>skipping to composables / purity / etc.</li>
<li>constant folding</li>
<li>observe scopes / recomposition / invalidation</li>
<li>composable inference</li>
<li>gap buffer slot table</li>
</ul></div><a href="/">Back to Home</a><div class="bio__Container-hbzvw6-0 eYyouk"><div class="bio__TextContainer-hbzvw6-1 fnCCfl"><h3 class="bio__Name-hbzvw6-3 jqdpqf">Leland Richardson</h3><sub class="bio__TagLine-hbzvw6-4 ldSKzY">Personal blog of Leland Richardson.<br/>Software Engineer at Google working on Android. Previously Airbnb.</sub></div><div class="bio__ImageContainer-hbzvw6-2 hVzkRp"><div class=" gatsby-image-wrapper" style="position:relative;overflow:hidden;display:inline-block;width:156px;height:156px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAAFOUlEQVQ4y2WTC0xTVxjHL87Mx+KSmSzGmTmYmCkbSqaCMaioPJUpoIwiTGA8KhMqitAC7Xi0YJGW8ihU3lCRLspLLQJOB3NTYYrZpshDRnQSpoDMJ9Lee89/t5WamJ3k5Pvu+b7zu//vO+dQLMtSpkEIoTj/HWpmvHz50hNABTeHjdMG9t+JCUw+nhjlvk9xM+B27/AcUx7nzzIajFYWxhsYwzBWMwmbaZq+jplRXFiEsMAg+Hp5kmA/PyQdPIibXV2m0BAL8CwCODFW/4Nxi/EW0ED/IBPNj6GXLrFhly9bTlavXAH75bZk0cIP6QVz5tElqmPmPCPDFr4F5WDmMjlrgZH79+7R25w3kXA/P3JUICAZkaGkRBhNasTRxH2dA6Fmz8PiBe8xNztaaTPUYCh9S6WpTFOAgxLOsN9F8sFz8yCXSjS4oMpGT9kxPNEf57rZhj59PuyWLCHz352HYnGsKd8M5WARFqXUs2dPLD2j+3t7Yf/ZSqISJeGiphjn5TJcU8sxqsvHi+unub/2IytqD+bPnktSI4NMBTEzYsY46EJqYHDA81p3Bx5PjpsCRN/cTL5YZosqaQba8nPRqchEf7kKj2pygR4OiAforJHi4/c/gChqHzHDWNY4o/IQ1d1ztWJq+jmMRoNJOjlZo8UnixYh1H8vdrr5Yvc2dxTEhiMrLAjxX/vhJ20OBlrVCHFZi8xEgbnn3K1gZoAdVG2dcpg7aUy/mmZNwYY6HVbZfAq+rx881rtgjd2X2OnoCDeHNVhhbYd4b3ekBHkjzN0R1apMM5ChaTIDfESp8uLZwbt38PDhiGmR/Hn5V0iCg9GYIUFxVCiSfb9CQ3IcrucKodvPw42cOHRqRIjYvApNGtVrhUaacDATkKXy1Mm41fcHGZucwM3bN8iDvjtQHxHgYkEempOFKOF/i99L8/Diah1+SQzD0w4tpv65hNY4HkZ6us1AsAwIYYlpUtq64tH+4fvQtfxIysozyeVLrahOk6BRmoTMAB/w1jtB5OOB5pQIFO3dgZ6SLEzf0WHsYi1ecEcx9vQVmXxuINNGFtMGZpKqaGw7lZKVAn5MIJ2tFJEiXRMUGelQR/kjYL0DfNetRuhGJ8i8nZC2fS2a4nbhWYsULeevQt02gnz9X0TTNszUXRnHic6/u6h0pTJA+H0sjiTtozNkkcgvkpAsWQoOeLkgws0Zx+NicUutwGhjIWoFgehIcEe3OgEyXS+kun6SVd8P2eleY45+BKm63nRqjz81R5jCHxKn8iFKdGUKcnlQVtaTQFdXuH5uA8leH1TvD8JgcTzaE3dD6+8AbV4BFPpRknN6AMqmu6yiaQjy+sGpYw2D1uaXIlXIeRJZHCTiXbRcJSQbnHfgaHQwcbS1hof9Cgjc10HlvxHHeRtwOScE5Zoikn9uCMpzI0Rx5p5BfWEc8obBVDNMeyJjlsmKhJ6FlZVihPNjaXsbG6ZTo0C0jxexW7yYOC39iOxxsCV6EY9cKROTYoUMP9RWsVmFVYaqtj7knRlof/OO09J8rSx+qlRcun1HIPy3uuBs7lHj+cJjTHZMOBHzPEm7/ABaswRcK7Yy8owEY07qYSil8SjJy2xnjONzTftL639+zUqRfPMGusl5SwTP02OsVJyIsyopzuSmoSVbCL1cSAS7veHjtgUN2kKki2KnKgplqZZ9RTVN5kqp/LwQs83I5Fv91hppBh8ICVmoOBx7qFyS0KHLTHpUnRTDao7sJyHbXSe9tmzqOlWVm36iTGltgZVW1pj3nWy+QP0HeSTgCcW4TTwAAAAASUVORK5CYII=" alt="Leland Richardson" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;object-position:center;opacity:1;transition:opacity 0.5s;transition-delay:0.25s"/><noscript><picture><source srcSet="/static/6c2f2fd00cced646d2b72adfc80258b8/50a83/avatar-circle.png 1x" /><img width="156" height="156" src="/static/6c2f2fd00cced646d2b72adfc80258b8/50a83/avatar-circle.png" alt="Leland Richardson" style="position:absolute;top:0;left:0;transition:opacity 0.5s;transition-delay:0.5s;opacity:1;width:100%;height:100%;object-fit:cover;object-position:center"/></picture></noscript></div></div></div><ul class="post-styles__LinkList-axwg2q-3 iDGdFF"><li><a rel="prev" href="/one-concern-one-file/">← <!-- -->One Concern, One File</a></li><li><a rel="next" href="/content-on-declarative-ui/">Content on Declarative UI<!-- --> →</a></li></ul></article></div><footer class="layout__Footer-sc-14pgzi3-0 fjerEM"></footer></div></div><script>
  
  
  if(true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  }
  if (typeof ga === "function") {
    ga('create', 'UA-25127345-1', 'auto', {});
      
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-blog-post-js","jsonName":"compose-from-first-principles-4a3","path":"/compose-from-first-principles/"};window.dataPath="120/path---compose-from-first-principles-4-a-3-b89-60eUWdZcGprbfbfQC7rgKexDxLg";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app.1b56f0f3ea8e10aaf677.css","/app-de31d325c9748b7c69de.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-e3ca28e140b315b54f2e.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-de3c6a0173b5a6249af2.js"],"component---src-pages-404-js":["/component---src-pages-404-js-93d881da845364e6847e.js"],"component---src-pages-index-js":["/component---src-pages-index-js-bc6a9f83fd022b22768a.js"],"pages-manifest":["/pages-manifest-c774ac7c40a1765122f4.js"]};/*]]>*/</script><script src="/webpack-runtime-7e8dde12bbe8249ecfa7.js" async=""></script><script src="/app-de31d325c9748b7c69de.js" async=""></script><script src="/1-60be38d63a7fd6e426ec.js" async=""></script><script src="/component---src-templates-blog-post-js-de3c6a0173b5a6249af2.js" async=""></script><script src="/0-f4a92f803a58fa4f13be.js" async=""></script></body></html>