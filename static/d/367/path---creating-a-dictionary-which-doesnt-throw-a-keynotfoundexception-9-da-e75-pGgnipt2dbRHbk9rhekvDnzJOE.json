{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "ef1d2216-234b-589b-9d42-a504b1809d54",
      "excerpt": "I find it interesting when there are certain tasks in one language which feel simple, fluid, and elegant to write, when in another language…",
      "html": "<p>I find it interesting when there are certain tasks in one language which feel simple, fluid, and elegant to write, when in another language they feel sloppy and wrong. This happens every so often and I try to think of a clean way to solve such a problem. Often this doesn’t lead anywhere, but I wanted to briefly share something that did.</p>\n<h3>Dictionaries in JavaScript</h3>\n<p>In JavaScript, it is fairly commonplace to treat standard objects as a “hash map” or a dictionary / set of key value pairs. Indeed it could possibly not be simpler:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var dict = {}; // our dictionary</code></pre></div>\n<p>in this case we can set the dictionary entry for “foo” to be 1:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dict[&quot;foo&quot;] = &quot;xyz&quot;;</code></pre></div>\n<p>we can then retrieve it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var foo = dict[&quot;foo&quot;];</code></pre></div>\n<p>Pretty standard. What if we want to get a value, if it’s present, and a default if not?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var bar = dict[&quot;bar&quot;] || &quot;abc&quot;; // &quot;abc&quot; is our default value for &quot;bar&quot;</code></pre></div>\n<p>Pretty simple.  </p>\n<h3>Dictionaries in C</h3>\n<p>Now let’s jump over to C#. Of course, in C#‘s case, we are strictly typed… so we are going to need to declare a typed dictionary like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var dict = new Dictionary&lt;string,int&gt;();</code></pre></div>\n<p>Still pretty simple.  So now we want to add an entry… also pretty simple:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dict[&quot;foo&quot;] = 1; // using indexer\ndict.Add(&quot;foo&quot;, 1); // using .Add() method</code></pre></div>\n<p>Getting a value:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var foo = dict[&quot;foo&quot;];</code></pre></div>\n<p>This is all good and easy. But there <em>is</em> a bit of a difference between this line and the JavaScript equivalent:  in this case, we might have just thrown an error!</p>\n<p>If there is no entry for “foo” in the dictionary, then this will throw a <code class=\"language-text\">KeyNotFoundException</code>.</p>\n<p>This isn’t necessarily a bad thing. In many cases this is exactly what we want.  In fact, what is the alternative?</p>\n<p>You see, in JavaScript, we have a value <code class=\"language-text\">undefined</code> to specify these types of situations… the situations where you requested a value that has never been declared.  In C#, we just have <code class=\"language-text\">null</code>.</p>\n<p>The problem is, in C#, it is perfectly valid to <em>set</em> a value of the dictionary to <code class=\"language-text\">null</code>.  So how does one differentiate between accessing a key of a dictionary which has never been set, and accessing the key of a dictionary whose corresponding value is null?</p>\n<p>This question, of course, was asked by the creators of the language C# years ago, and the answer was to throw a <code class=\"language-text\">KeyNotFoundException</code> in the case of the former.</p>\n<p>Although I don’t disagree with their conclusion, I sometimes wish there was a different way. Sometimes I don’t want there to be a difference between a null value and the absense of a key.  Without implementing your own dictionary, the best you can do is this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">string bar;\nif(!dict.TryGetValue(&quot;bar&quot;, out bar) || bar == null){\n    bar = &quot;abc&quot;;\n}\n// do something with bar</code></pre></div>\n<p>That just seems a bit verbose to me. The alternate syntax would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var bar = dict[&quot;bar&quot;] ?? &quot;abc&quot;;</code></pre></div>\n<p>Of course, this is actually quite simple to obtain if you just implement your own “safe” version of Dictionary:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class SafeDictionary&lt;TKey, TValue&gt; : Dictionary&lt;TKey, TValue&gt; where TValue : class\n{\n    public new void Add(TKey key, TValue value)\n    {\n        if (value == null)\n        {\n            // adding null value is pointless...\n            return;\n        }\n        base.Add(key, value);\n    }\n\n    public new void Remove(TKey key)\n    {\n        if (!ContainsKey(key))\n        {\n            // nothing to do\n            return;\n        }\n        base.Remove(key);\n    }\n\n    public new TValue this[TKey key]\n    {\n        get\n        {\n            TValue value;\n            return TryGetValue(key, out value) ? value : null;\n        }\n        set\n        {\n            if (value == null)\n            {\n                // setting value null is same as removing it\n                Remove(key);\n            }\n            else\n            {\n                base[key] = value;\n            }\n        }\n    }\n}</code></pre></div>\n<p>The most significant limitation here is that you have to restrict <code class=\"language-text\">TValue</code> to <code class=\"language-text\">where TValue : class</code>, so as to make it nullable.</p>\n<p>I’m not sure if anyone else has struggled with this as an issue, but if so, feel free to use the above class!</p>",
      "fields": { "readingTime": { "text": "4 min read" } },
      "frontmatter": { "title": "", "date": null }
    }
  },
  "pageContext": {
    "slug": "/creating-a-dictionary-which-doesnt-throw-a-keynotfoundexception/",
    "previous": {
      "fields": { "slug": "/free-google-speech-recognition-api/" },
      "frontmatter": { "title": "" }
    },
    "next": {
      "fields": { "slug": "/a-pattern-for-writing-css-to-scale/" },
      "frontmatter": { "title": "" }
    }
  }
}
