{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "6ab5b53c-d9a5-5810-a83d-28d2a6c83995",
      "excerpt": "Lucene is a document storage search engine library that utilizes inverted indexes and has great capabilities.  It has been very popular and…",
      "html": "<p>Lucene is a document storage search engine library that utilizes inverted indexes and has great capabilities.  It has been very popular and has been ported to almost every language, including .Net.</p>\n<p>We use Lucene.Net for search here at Tech.Pro. Lucene has incredibly useful features, but it is built to work solely with strings, which can be a strong disadvantage if one is trying to store data of other types in a document.  In addition, translating documents to strongly typed objects can be an annoying and redundant task.</p>\n<p>We also use Dapper.Net here at Tech.Pro, and we love it’s simple API and extremely satisfactory performance.</p>\n<h2>Purpose</h2>\n<p>The concept I am trying to achieve is something similar in spirit to <a href=\"http://code.google.com/p/dapper-dot-net/\">Dapper</a>, except is meant to deal with mapping Lucene Documents to generic Objects, rather than Rows from a database.</p>\n<p>Although Lucene is schema-less, in practice there is often an implicit schema in a Document which corresponds to a class or object in your code-base.  Although you can easily use ORMs like Dapper or EntityFramework to map data from an RDBMS to CLR objects, doing so in Lucene is cumbersome and error-prone.  Enter LukeMapper:</p>\n<p>The desired API is something like the following:</p>\n<p>Given some generic class in .Net like as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">PocoClass</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> Id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">string</span> Name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> PropId <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">set</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">string</span> PropName <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">set</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Read Operations</h2>\n<p>If I wanted to run a query against an <code class=\"language-text\">IndexSearcher</code> in Lucene, and return the corresponding documents\nmapped to a List<PocoClass>, I could do the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\">IndexSearcher</span> searcher<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Query</span> qry<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> numberToReturn <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nList<span class=\"token operator\">&lt;</span>PocoClass<span class=\"token operator\">></span> results <span class=\"token operator\">=</span> searcher<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">Query</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PocoClass</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>qry<span class=\"token punctuation\">,</span> numberToReturn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Thus, the <code class=\"language-text\">.Query&lt;T&gt;(Query,int)</code> method is implemented as an extension method to an <code class=\"language-text\">IndexSearcher</code>, similar to\nhow Dapper’s <code class=\"language-text\">.Query&lt;T&gt;</code> method is implemented as an extension method to an <code class=\"language-text\">IDBConnection</code> object.</p>\n<h2>Write Operations</h2>\n<p>Similarly, for Write operations, I would do the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\">IndexWriter</span> writer<span class=\"token punctuation\">;</span>\nIEnumerable<span class=\"token operator\">&lt;</span>PocoClass<span class=\"token operator\">></span> objects<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// insert objects into index</span>\nwriter<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>objects<span class=\"token punctuation\">)</span></code></pre></div>\n<p>And similarly, an update operation:\n</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token class-name\">IndexWriter</span> writer<span class=\"token punctuation\">;</span>\nIEnumerable<span class=\"token operator\">&lt;</span>PocoClass<span class=\"token operator\">></span> objects<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//method to find the corresponding document to update</span>\nFunc<span class=\"token operator\">&lt;</span>PocoClass<span class=\"token punctuation\">,</span> Query<span class=\"token operator\">></span> identifyingQuery <span class=\"token operator\">=</span> o <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TermQuery</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Term</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Id\"</span><span class=\"token punctuation\">,</span>o<span class=\"token punctuation\">.</span>Id<span class=\"token punctuation\">.</span><span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// update objects in index</span>\nwriter<span class=\"token punctuation\">.</span><span class=\"token function\">Update</span><span class=\"token punctuation\">(</span>objects<span class=\"token punctuation\">,</span> identifyingQuery<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Similar to Dapper and <a href=\"https://github.com/sapiens/SqlFu\">other Micro-ORMs out there</a>, the implementation of the <strong>mapping will be done by generating a Deserializer/Serializer method via IL-Generation and caching it</strong>.</p>\n<p>For the <code class=\"language-text\">.Query()</code> operation, the desired IL method generated should be semantically similar to the IL generated from the following method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static PocoClass ExampleDeserializerMethod(Document document)\n{\n    var poco = new PocoClass();\n\n    poco.Id = Convert.ToInt32(document.Get(&quot;Id&quot;));\n    poco.Name = document.Get(&quot;Name&quot;);\n\n    poco.PropId = Convert.ToInt32(document.Get(&quot;PropId&quot;));\n    poco.PropName = document.Get(&quot;PropName&quot;);\n\n    return poco;\n}</code></pre></div>\n<p>Similarly, for the <code class=\"language-text\">.Write()</code> and <code class=\"language-text\">Update()</code> methods, the Serializer methods will be semantically similar to the IL generated from the following method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static Document ExampleSerializerMethod(PocoClass obj)\n{\n    var doc = new Document();\n\n    doc.Add(new Field(&quot;Id&quot;, obj.Id.ToString(), Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));\n\tdoc.Add(new Field(&quot;Name&quot;, obj.Name, Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));\n\tdoc.Add(new Field(&quot;PropId&quot;, obj.PropId.ToString(), Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));\n\tdoc.Add(new Field(&quot;PropName&quot;, obj.PropName, Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));\n\n    return doc;\n}</code></pre></div>\n<p>Although, some error handling may need to be inserted, among other things to make the method a bit more robust.</p>\n<h2>Enhancing / Customizing with Attributes</h2>\n<p>Although basic functionality works essentially out of the box, with no attributes needed, further flexibility is garnered by the use of various Attributes.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[LukeMapper(IgnoreByDefault = true)]\npublic class ExampleClass\n{\n    // doesn&#39;t get indexed/stored\n    [Luke(Store = Store.YES)]\n    public int Id { get; set; }\n    \n    // doesn&#39;t get stored, but is indexed in &quot;searchtext&quot; field\n    [Luke(Store = Store.NO, Index = Index.ANALYZED, FieldName = &quot;searchtext&quot;)]\n    public string Title { get; set; }\n\n    // doesn&#39;t get stored, but is indexed in &quot;searchtext&quot; field\n    [Luke(Store = Store.NO, Index = Index.ANALYZED, FieldName = &quot;searchtext&quot;)]\n    public string Body { get; set; }\n\n    // doesn&#39;t get indexed/stored\n    public int IgnoredProperty { get; set; }\n}\n\n[LukeMapper(DefaultIndex = Index.ANALYZED)]\npublic class ExampleClass\n{\n    // doesn&#39;t get indexed/stored\n    [Luke(Index = Index.NOT_ANALYZED_NO_NORMS)]\n    public int Id { get; set; }\n\n    // get&#39;s analyzed, AND stored\n    public string Title { get; set; }\n\n    // get&#39;s analyzed, AND stored\n    public string Body { get; set; }\n}\n\npublic class ExampleClass\n{\n    // everything get&#39;s indexed and stored by default\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Body { get; set; }\n\n    //opt-in ignored per property/field\n    [Luke(Ignore=true)]\n    public int Ignored { get; set; }\n}\n\npublic class ExampleClass\n{\n    // everything get&#39;s indexed and stored by default\n    public int Id { get; set; }\n    public string Title { get; set; }\n    public string Body { get; set; }\n\n    //opt-in ignored per property/field\n    public int Ignored { get; set; }\n}</code></pre></div>\n<h2>Custom Serialization/Deserialization</h2>\n<p>You can override the serialization of certain properties, even more complex ones which are not supported, if it is needed for your application.</p>\n<p>For instance, a common example might be that I have a list or array of something that I would like to serialize/deserialize into the document.</p>\n<p>In this case, you can simply specify a static method to use for the serialization (and deserialization) using the <code class=\"language-text\">LukeSerializerAttribute</code> and <code class=\"language-text\">LukeDeserializerAttribute</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestCustomSerializerClass\n{\n    public int Id { get; set; }\n\n    //this list would typically be ignored\n    public List&lt;string&gt; CustomList { get; set; }\n\n    // if you specify a serializer, it will get serialized\n    [LukeSerializer(&quot;CustomList&quot;)]\n    public static string CustomListToString(List&lt;string&gt; list)\n    {\n        return string.Join(&quot;,&quot;, list);\n    }\n\n    // and similarly, deserialized\n    [LukeDeserializer(&quot;CustomList&quot;)]\n    public static List&lt;string&gt; StringToCustomList(string serialized)\n    {\n        return serialized.Split(&#39;,&#39;).ToList();\n    }\n}\n\n\npublic class TestCustomSerializerClass\n{\n    public int Id { get; set; }\n\n    // maybe you just want to index the list for search, but don&#39;t need it on .Query()\n    [Luke(Store = Store.NO,Index = Index.ANALYZED)]\n    public List&lt;string&gt; CustomList { get; set; }\n\n    // in this case, only a serializer is needed\n    [LukeSerializer(&quot;CustomList&quot;)]\n    public static string CustomListToString(List&lt;string&gt; list)\n    {\n        return string.Join(&quot; &quot;, list);\n    }\n}</code></pre></div>\n<p>As of now, the cacheing is done via a hashcode which should be unique to the declared fields in the <code class=\"language-text\">IndexSearcher</code>’s index,\nand the object type which it is being mapped to.</p>\n<h2>Data Types supported:</h2>\n<ul>\n<li>\n<p>Textual:</p>\n<ul>\n<li><code class=\"language-text\">string</code></li>\n<li><code class=\"language-text\">char</code></li>\n</ul>\n</li>\n<li>\n<p>Numeric:</p>\n<ul>\n<li><code class=\"language-text\">int</code></li>\n<li><code class=\"language-text\">int?</code></li>\n<li><code class=\"language-text\">long</code></li>\n<li><code class=\"language-text\">long?</code></li>\n</ul>\n</li>\n<li>\n<p>Other:</p>\n<ul>\n<li><code class=\"language-text\">bool</code></li>\n<li><code class=\"language-text\">bool?</code></li>\n<li><code class=\"language-text\">DateTime</code></li>\n<li><code class=\"language-text\">DateTime?</code></li>\n</ul>\n</li>\n<li>\n<p>In Progress (Not Yet Supported):</p>\n<ul>\n<li><code class=\"language-text\">char?</code></li>\n<li><code class=\"language-text\">byte</code></li>\n<li><code class=\"language-text\">byte?</code></li>\n</ul>\n</li>\n</ul>\n<h2>Performance</h2>\n<p>With an example class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestClass\n{\n    public int Id;\n\n    public string PropString { get; set; }\n}</code></pre></div>\n<p>The test was to instantiate 500 instances of <code class=\"language-text\">TestClass</code>, and compared inserting the </p>\n<table class=\"table table-bordered\">\n<tr>\n    <th>Operation</th>\n    <th>LukeMapper</th>\n    <th>Lucene.Net (native)</th>\n</tr>\n<tr>\n    <td>Insert 500 Documents (With no Serializer Cached)</td>\n    <td>89ms</td>\n    <td>19ms</td>\n</tr>\n<tr>\n    <td>Insert 500 Documents (Subsequent Calls)</td>\n    <td>3.31ms</td>\n    <td>4.52ms</td>\n</tr>\n<tr>\n    <td>Query 500 Documents (With no Deserializer Cached)</td>\n    <td>49ms</td>\n    <td>1ms</td>\n</tr>\n<tr>\n    <td>Query 500 Documents (Subsequent Calls)</td>\n    <td>1.26ms</td>\n    <td>1.05ms</td>\n</tr>\n</table>\n<p>This is a simple class, with only a string and an int, so I ran a second test with 2 more properties:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class TestClass1\n{\n    public int Id;\n    public string PropString { get; set; }\n    public DateTime DateTime { get; set; }\n    public int? NullId { get; set; }\n}</code></pre></div>\n<p>Which had the following similar performance:</p>\n<table class=\"table table-bordered\">\n<tr>\n    <th>Operation</th>\n    <th>LukeMapper</th>\n    <th>Lucene.Net (native)</th>\n</tr>\n<tr>\n    <td>Insert 500 Documents (With no Serializer Cached)</td>\n    <td>103ms</td>\n    <td>23ms</td>\n</tr>\n<tr>\n    <td>Insert 500 Documents (Subsequent Calls)</td>\n    <td>5.84ms</td>\n    <td>6.05ms</td>\n</tr>\n<tr>\n    <td>Query 500 Documents (With no Deserializer Cached)</td>\n    <td>42ms</td>\n    <td>2ms</td>\n</tr>\n<tr>\n    <td>Query 500 Documents (Subsequent Calls)</td>\n    <td>1.84ms</td>\n    <td>1.15ms</td>\n</tr>\n</table>\n<p>What these benchmarks show is essentially what is to be expected.  The first time <code class=\"language-text\">.Write()</code> is called on a class, it takes O(10^2) ms to generate the deserializer/serializer method.  Once it is cached, the write and read operations are of the same order as the native calls (which they should be, since we are generating essentially the same CIL as when we are hand-coding it).  What is a bit mysterious to me is why LukeMapper seems to consistently be writing to the index faster.  This may be an issue with the benchmark.  You can find the actual code used to find these numbers <a href=\"https://github.com/lelandrichardson/LukeMapper/blob/master/LukeMapper.Benchmarks/Program.cs\">here</a></p>\n<p>If anyone would like me to compare it to anything else, let me know.  As far as I know there aren’t really any other ORMs for lucene out there to compare against.</p>\n<h2>Pseudo-Code: Under The Hood</h2>\n<p>The code of LukeMapper is essentially a <a href=\"https://github.com/lelandrichardson/LukeMapper/blob/master/LukeMapper.cs\">single file</a> which exposes several extension methods to <code class=\"language-text\">IndexWriter</code> and <code class=\"language-text\">IndexSearcher</code>.</p>\n<p>The <code class=\"language-text\">.Query()</code> method might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static IEnumerable&lt;T&gt; Query&lt;T&gt;(\n    this IndexSearcher searcher, \n    Query query, \n    int n /*, Sort sort*/)\n{\n    // run actual search\n    TopDocs td = searcher.Search(query, n);\n    \n    // if no results, nothing to do\n    if (td.TotalHits == 0)\n    {\n        yield break;\n    }\n    \n    //check to see if we have a deserializer\n    var deserializer = Cache.Get(typeof(T),searcher);\n    \n    if(deserializer = null){\n        // need to generate deserializer\n        deserializer = GenerateDeserializer(typeof(T),searcher);\n    }\n    \n    //perform mapping\n    foreach(var document in td.ScoreDocs.Select(sd=&gt;searcher.Doc(sd.doc)))\n    {\n        object next;\n        next = deserializer(document);\n        yield return (T)next;\n    }\n}</code></pre></div>\n<p>All of the magic is essentially in the <code class=\"language-text\">GenerateDeserializer</code> method.  This is where reflection is used to determine what IL to generate and cache as a method.  In some seriously simplified pseudo-code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private static Func&lt;Document, object&gt; GenerateDeserializer(Type type, IndexSearcher searcher)\n{\n    var dm = new DynamicMethod(...);\n    var il = dm.GetILGenerator();\n\n    var properties = GetSettableProps(type);\n    var fields = GetSettableFields(type);\n    var attributes = GetLukeAttributes(type);\n\n    foreach(var prop in properties){\n        // figure out prop type, attributes, etc. and emit proper IL.\n        il.Emit(...);\n        il.Emit(...);\n        il.Emit(...);\n    }\n    foreach(var field in fields){\n        // figure out prop type, attributes, etc. and emit proper IL.\n        il.Emit(...);\n        il.Emit(...);\n        il.Emit(...);\n    }\n    \n    return (Func&lt;Document, object&gt;)dm.CreateDelegate(typeof(Func&lt;Document, object&gt;));\n}</code></pre></div>\n<p>The methods for generating serializer methods are very similar.</p>\n<p>If you are interested in the code, you can see it all on <a href=\"https://github.com/lelandrichardson/LukeMapper\">github</a></p>\n<h3>Notes</h3>\n<p>In many ways this is not as practical as Dapper and is more of a specific application; Lucene is only meant to handle textual data and is schema-less, so mapping to objects of non-textual type with a specific schema is more error prone. The reality, though, is that most Lucene indexes are implemented with a relatively uniform schema.</p>\n<h3>Current Status</h3>\n<p>I have started working on this project more and think it has promise and will likely use it in some projects of my own.  If anyone is interested in helping out, I would certainly love the help.  On the other hand, if anyone has any suggestions or feature requests, bring them on. Although this is not currently used in the Tech.Pro codebase, it will be soon.</p>\n<p>Right now, I am focusing on the following:</p>\n<ul>\n<li>Improve the error handling / feedback currently</li>\n<li>Build in some support for <code class=\"language-text\">NumericField</code>s</li>\n<li>Attribute to specify the “Identifier” of an object, and auto-generate the “identifyingQuery” needed for the <code class=\"language-text\">Update()</code> method.</li>\n<li>Attribute to utilize term vectors usefully</li>\n<li>Build in some automatic support for handling lists in typical fashion (ie csv, json-encoding, etc)</li>\n<li>get <code class=\"language-text\">char</code>’s and <code class=\"language-text\">byte</code>’s working (seriously, why are they so difficult?)</li>\n<li>I would like to get the project hosted on NuGet.  Need to look into this as I have never done it.</li>\n</ul>\n<p><strong>Link to <a href=\"https://github.com/lelandrichardson/LukeMapper\">LukeMapper GitHub Repo</a></strong></p>\n<p>Any and all comments/feedback appreciated!</p>",
      "fields": { "readingTime": { "text": "10 min read" } },
      "frontmatter": {
        "title": "Lukemapper: A Super Fast ORM for Lucene.net",
        "date": "February 11, 2013"
      }
    }
  },
  "pageContext": {
    "slug": "/lukemapper-a-super-fast-orm-for-lucenenet/",
    "previous": {
      "fields": { "slug": "/_generation-rss-feed-actions-in-aspnet-mvc/" },
      "frontmatter": { "title": "Generation RSS Feed Actions in ASP.NET MVC" }
    },
    "next": {
      "fields": {
        "slug": "/_building-an-image-uploading--resizing-framework-in-aspnet/"
      },
      "frontmatter": {
        "title": "Building an Image Uploading & Resizing Framework in ASP.Net"
      }
    }
  }
}
